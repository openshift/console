/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/activitypub/user-id/{user-id}": {
    get: operations["activitypubPerson"];
  };
  "/activitypub/user-id/{user-id}/inbox": {
    post: operations["activitypubPersonInbox"];
  };
  "/admin/cron": {
    get: operations["adminCronList"];
  };
  "/admin/cron/{task}": {
    post: operations["adminCronRun"];
  };
  "/admin/emails": {
    get: operations["adminGetAllEmails"];
  };
  "/admin/emails/search": {
    get: operations["adminSearchEmails"];
  };
  "/admin/hooks": {
    get: operations["adminListHooks"];
    post: operations["adminCreateHook"];
  };
  "/admin/hooks/{id}": {
    get: operations["adminGetHook"];
    delete: operations["adminDeleteHook"];
    patch: operations["adminEditHook"];
  };
  "/admin/orgs": {
    get: operations["adminGetAllOrgs"];
  };
  "/admin/runners/registration-token": {
    get: operations["adminGetRunnerRegistrationToken"];
  };
  "/admin/unadopted": {
    get: operations["adminUnadoptedList"];
  };
  "/admin/unadopted/{owner}/{repo}": {
    post: operations["adminAdoptRepository"];
    delete: operations["adminDeleteUnadoptedRepository"];
  };
  "/admin/users": {
    get: operations["adminSearchUsers"];
    post: operations["adminCreateUser"];
  };
  "/admin/users/{username}": {
    delete: operations["adminDeleteUser"];
    patch: operations["adminEditUser"];
  };
  "/admin/users/{username}/badges": {
    get: operations["adminListUserBadges"];
    post: operations["adminAddUserBadges"];
    delete: operations["adminDeleteUserBadges"];
  };
  "/admin/users/{username}/keys": {
    post: operations["adminCreatePublicKey"];
  };
  "/admin/users/{username}/keys/{id}": {
    delete: operations["adminDeleteUserPublicKey"];
  };
  "/admin/users/{username}/orgs": {
    post: operations["adminCreateOrg"];
  };
  "/admin/users/{username}/rename": {
    post: operations["adminRenameUser"];
  };
  "/admin/users/{username}/repos": {
    post: operations["adminCreateRepo"];
  };
  "/gitignore/templates": {
    get: operations["listGitignoresTemplates"];
  };
  "/gitignore/templates/{name}": {
    get: operations["getGitignoreTemplateInfo"];
  };
  "/label/templates": {
    get: operations["listLabelTemplates"];
  };
  "/label/templates/{name}": {
    get: operations["getLabelTemplateInfo"];
  };
  "/licenses": {
    get: operations["listLicenseTemplates"];
  };
  "/licenses/{name}": {
    get: operations["getLicenseTemplateInfo"];
  };
  "/markdown": {
    post: operations["renderMarkdown"];
  };
  "/markdown/raw": {
    post: operations["renderMarkdownRaw"];
  };
  "/markup": {
    post: operations["renderMarkup"];
  };
  "/nodeinfo": {
    get: operations["getNodeInfo"];
  };
  "/notifications": {
    get: operations["notifyGetList"];
    put: operations["notifyReadList"];
  };
  "/notifications/new": {
    get: operations["notifyNewAvailable"];
  };
  "/notifications/threads/{id}": {
    get: operations["notifyGetThread"];
    patch: operations["notifyReadThread"];
  };
  "/org/{org}/repos": {
    post: operations["createOrgRepoDeprecated"];
  };
  "/orgs": {
    get: operations["orgGetAll"];
    post: operations["orgCreate"];
  };
  "/orgs/{org}": {
    get: operations["orgGet"];
    delete: operations["orgDelete"];
    patch: operations["orgEdit"];
  };
  "/orgs/{org}/actions/runners/registration-token": {
    get: operations["orgGetRunnerRegistrationToken"];
  };
  "/orgs/{org}/actions/secrets": {
    get: operations["orgListActionsSecrets"];
  };
  "/orgs/{org}/actions/secrets/{secretname}": {
    put: operations["updateOrgSecret"];
    delete: operations["deleteOrgSecret"];
  };
  "/orgs/{org}/actions/variables": {
    get: operations["getOrgVariablesList"];
  };
  "/orgs/{org}/actions/variables/{variablename}": {
    get: operations["getOrgVariable"];
    put: operations["updateOrgVariable"];
    post: operations["createOrgVariable"];
    delete: operations["deleteOrgVariable"];
  };
  "/orgs/{org}/activities/feeds": {
    get: operations["orgListActivityFeeds"];
  };
  "/orgs/{org}/avatar": {
    post: operations["orgUpdateAvatar"];
    delete: operations["orgDeleteAvatar"];
  };
  "/orgs/{org}/blocks": {
    get: operations["organizationListBlocks"];
  };
  "/orgs/{org}/blocks/{username}": {
    get: operations["organizationCheckUserBlock"];
    put: operations["organizationBlockUser"];
    delete: operations["organizationUnblockUser"];
  };
  "/orgs/{org}/hooks": {
    get: operations["orgListHooks"];
    post: operations["orgCreateHook"];
  };
  "/orgs/{org}/hooks/{id}": {
    get: operations["orgGetHook"];
    delete: operations["orgDeleteHook"];
    patch: operations["orgEditHook"];
  };
  "/orgs/{org}/labels": {
    get: operations["orgListLabels"];
    post: operations["orgCreateLabel"];
  };
  "/orgs/{org}/labels/{id}": {
    get: operations["orgGetLabel"];
    delete: operations["orgDeleteLabel"];
    patch: operations["orgEditLabel"];
  };
  "/orgs/{org}/members": {
    get: operations["orgListMembers"];
  };
  "/orgs/{org}/members/{username}": {
    get: operations["orgIsMember"];
    delete: operations["orgDeleteMember"];
  };
  "/orgs/{org}/public_members": {
    get: operations["orgListPublicMembers"];
  };
  "/orgs/{org}/public_members/{username}": {
    get: operations["orgIsPublicMember"];
    put: operations["orgPublicizeMember"];
    delete: operations["orgConcealMember"];
  };
  "/orgs/{org}/repos": {
    get: operations["orgListRepos"];
    post: operations["createOrgRepo"];
  };
  "/orgs/{org}/teams": {
    get: operations["orgListTeams"];
    post: operations["orgCreateTeam"];
  };
  "/orgs/{org}/teams/search": {
    get: operations["teamSearch"];
  };
  "/packages/{owner}": {
    get: operations["listPackages"];
  };
  "/packages/{owner}/{type}/{name}/{version}": {
    get: operations["getPackage"];
    delete: operations["deletePackage"];
  };
  "/packages/{owner}/{type}/{name}/{version}/files": {
    get: operations["listPackageFiles"];
  };
  "/repos/issues/search": {
    get: operations["issueSearchIssues"];
  };
  "/repos/migrate": {
    post: operations["repoMigrate"];
  };
  "/repos/search": {
    get: operations["repoSearch"];
  };
  "/repos/{owner}/{repo}": {
    get: operations["repoGet"];
    delete: operations["repoDelete"];
    patch: operations["repoEdit"];
  };
  "/repos/{owner}/{repo}/actions/secrets": {
    get: operations["repoListActionsSecrets"];
  };
  "/repos/{owner}/{repo}/actions/secrets/{secretname}": {
    put: operations["updateRepoSecret"];
    delete: operations["deleteRepoSecret"];
  };
  "/repos/{owner}/{repo}/actions/tasks": {
    get: operations["ListActionTasks"];
  };
  "/repos/{owner}/{repo}/actions/variables": {
    get: operations["getRepoVariablesList"];
  };
  "/repos/{owner}/{repo}/actions/variables/{variablename}": {
    get: operations["getRepoVariable"];
    put: operations["updateRepoVariable"];
    post: operations["createRepoVariable"];
    delete: operations["deleteRepoVariable"];
  };
  "/repos/{owner}/{repo}/activities/feeds": {
    get: operations["repoListActivityFeeds"];
  };
  "/repos/{owner}/{repo}/archive/{archive}": {
    get: operations["repoGetArchive"];
  };
  "/repos/{owner}/{repo}/assignees": {
    get: operations["repoGetAssignees"];
  };
  "/repos/{owner}/{repo}/avatar": {
    post: operations["repoUpdateAvatar"];
    delete: operations["repoDeleteAvatar"];
  };
  "/repos/{owner}/{repo}/branch_protections": {
    get: operations["repoListBranchProtection"];
    post: operations["repoCreateBranchProtection"];
  };
  "/repos/{owner}/{repo}/branch_protections/{name}": {
    get: operations["repoGetBranchProtection"];
    delete: operations["repoDeleteBranchProtection"];
    patch: operations["repoEditBranchProtection"];
  };
  "/repos/{owner}/{repo}/branches": {
    get: operations["repoListBranches"];
    post: operations["repoCreateBranch"];
  };
  "/repos/{owner}/{repo}/branches/{branch}": {
    get: operations["repoGetBranch"];
    delete: operations["repoDeleteBranch"];
  };
  "/repos/{owner}/{repo}/collaborators": {
    get: operations["repoListCollaborators"];
  };
  "/repos/{owner}/{repo}/collaborators/{collaborator}": {
    get: operations["repoCheckCollaborator"];
    put: operations["repoAddCollaborator"];
    delete: operations["repoDeleteCollaborator"];
  };
  "/repos/{owner}/{repo}/collaborators/{collaborator}/permission": {
    get: operations["repoGetRepoPermissions"];
  };
  "/repos/{owner}/{repo}/commits": {
    get: operations["repoGetAllCommits"];
  };
  "/repos/{owner}/{repo}/commits/{ref}/status": {
    get: operations["repoGetCombinedStatusByRef"];
  };
  "/repos/{owner}/{repo}/commits/{ref}/statuses": {
    get: operations["repoListStatusesByRef"];
  };
  "/repos/{owner}/{repo}/commits/{sha}/pull": {
    get: operations["repoGetCommitPullRequest"];
  };
  "/repos/{owner}/{repo}/compare/{basehead}": {
    get: operations["repoCompareDiff"];
  };
  "/repos/{owner}/{repo}/contents": {
    get: operations["repoGetContentsList"];
    post: operations["repoChangeFiles"];
  };
  "/repos/{owner}/{repo}/contents/{filepath}": {
    get: operations["repoGetContents"];
    put: operations["repoUpdateFile"];
    post: operations["repoCreateFile"];
    delete: operations["repoDeleteFile"];
  };
  "/repos/{owner}/{repo}/diffpatch": {
    post: operations["repoApplyDiffPatch"];
  };
  "/repos/{owner}/{repo}/editorconfig/{filepath}": {
    get: operations["repoGetEditorConfig"];
  };
  "/repos/{owner}/{repo}/forks": {
    get: operations["listForks"];
    post: operations["createFork"];
  };
  "/repos/{owner}/{repo}/git/blobs/{sha}": {
    get: operations["GetBlob"];
  };
  "/repos/{owner}/{repo}/git/commits/{sha}": {
    get: operations["repoGetSingleCommit"];
  };
  "/repos/{owner}/{repo}/git/commits/{sha}.{diffType}": {
    get: operations["repoDownloadCommitDiffOrPatch"];
  };
  "/repos/{owner}/{repo}/git/notes/{sha}": {
    get: operations["repoGetNote"];
  };
  "/repos/{owner}/{repo}/git/refs": {
    get: operations["repoListAllGitRefs"];
  };
  "/repos/{owner}/{repo}/git/refs/{ref}": {
    get: operations["repoListGitRefs"];
  };
  "/repos/{owner}/{repo}/git/tags/{sha}": {
    get: operations["GetAnnotatedTag"];
  };
  "/repos/{owner}/{repo}/git/trees/{sha}": {
    get: operations["GetTree"];
  };
  "/repos/{owner}/{repo}/hooks": {
    get: operations["repoListHooks"];
    post: operations["repoCreateHook"];
  };
  "/repos/{owner}/{repo}/hooks/git": {
    get: operations["repoListGitHooks"];
  };
  "/repos/{owner}/{repo}/hooks/git/{id}": {
    get: operations["repoGetGitHook"];
    delete: operations["repoDeleteGitHook"];
    patch: operations["repoEditGitHook"];
  };
  "/repos/{owner}/{repo}/hooks/{id}": {
    get: operations["repoGetHook"];
    delete: operations["repoDeleteHook"];
    patch: operations["repoEditHook"];
  };
  "/repos/{owner}/{repo}/hooks/{id}/tests": {
    post: operations["repoTestHook"];
  };
  "/repos/{owner}/{repo}/issue_config": {
    get: operations["repoGetIssueConfig"];
  };
  "/repos/{owner}/{repo}/issue_config/validate": {
    get: operations["repoValidateIssueConfig"];
  };
  "/repos/{owner}/{repo}/issue_templates": {
    get: operations["repoGetIssueTemplates"];
  };
  "/repos/{owner}/{repo}/issues": {
    get: operations["issueListIssues"];
    post: operations["issueCreateIssue"];
  };
  "/repos/{owner}/{repo}/issues/comments": {
    get: operations["issueGetRepoComments"];
  };
  "/repos/{owner}/{repo}/issues/comments/{id}": {
    get: operations["issueGetComment"];
    delete: operations["issueDeleteComment"];
    patch: operations["issueEditComment"];
  };
  "/repos/{owner}/{repo}/issues/comments/{id}/assets": {
    get: operations["issueListIssueCommentAttachments"];
    post: operations["issueCreateIssueCommentAttachment"];
  };
  "/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}": {
    get: operations["issueGetIssueCommentAttachment"];
    delete: operations["issueDeleteIssueCommentAttachment"];
    patch: operations["issueEditIssueCommentAttachment"];
  };
  "/repos/{owner}/{repo}/issues/comments/{id}/reactions": {
    get: operations["issueGetCommentReactions"];
    post: operations["issuePostCommentReaction"];
    delete: operations["issueDeleteCommentReaction"];
  };
  "/repos/{owner}/{repo}/issues/pinned": {
    get: operations["repoListPinnedIssues"];
  };
  "/repos/{owner}/{repo}/issues/{index}": {
    get: operations["issueGetIssue"];
    delete: operations["issueDelete"];
    patch: operations["issueEditIssue"];
  };
  "/repos/{owner}/{repo}/issues/{index}/assets": {
    get: operations["issueListIssueAttachments"];
    post: operations["issueCreateIssueAttachment"];
  };
  "/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}": {
    get: operations["issueGetIssueAttachment"];
    delete: operations["issueDeleteIssueAttachment"];
    patch: operations["issueEditIssueAttachment"];
  };
  "/repos/{owner}/{repo}/issues/{index}/blocks": {
    get: operations["issueListBlocks"];
    post: operations["issueCreateIssueBlocking"];
    delete: operations["issueRemoveIssueBlocking"];
  };
  "/repos/{owner}/{repo}/issues/{index}/comments": {
    get: operations["issueGetComments"];
    post: operations["issueCreateComment"];
  };
  "/repos/{owner}/{repo}/issues/{index}/comments/{id}": {
    delete: operations["issueDeleteCommentDeprecated"];
    patch: operations["issueEditCommentDeprecated"];
  };
  "/repos/{owner}/{repo}/issues/{index}/deadline": {
    post: operations["issueEditIssueDeadline"];
  };
  "/repos/{owner}/{repo}/issues/{index}/dependencies": {
    get: operations["issueListIssueDependencies"];
    post: operations["issueCreateIssueDependencies"];
    delete: operations["issueRemoveIssueDependencies"];
  };
  "/repos/{owner}/{repo}/issues/{index}/labels": {
    get: operations["issueGetLabels"];
    put: operations["issueReplaceLabels"];
    post: operations["issueAddLabel"];
    delete: operations["issueClearLabels"];
  };
  "/repos/{owner}/{repo}/issues/{index}/labels/{id}": {
    delete: operations["issueRemoveLabel"];
  };
  "/repos/{owner}/{repo}/issues/{index}/pin": {
    post: operations["pinIssue"];
    delete: operations["unpinIssue"];
  };
  "/repos/{owner}/{repo}/issues/{index}/pin/{position}": {
    patch: operations["moveIssuePin"];
  };
  "/repos/{owner}/{repo}/issues/{index}/reactions": {
    get: operations["issueGetIssueReactions"];
    post: operations["issuePostIssueReaction"];
    delete: operations["issueDeleteIssueReaction"];
  };
  "/repos/{owner}/{repo}/issues/{index}/stopwatch/delete": {
    delete: operations["issueDeleteStopWatch"];
  };
  "/repos/{owner}/{repo}/issues/{index}/stopwatch/start": {
    post: operations["issueStartStopWatch"];
  };
  "/repos/{owner}/{repo}/issues/{index}/stopwatch/stop": {
    post: operations["issueStopStopWatch"];
  };
  "/repos/{owner}/{repo}/issues/{index}/subscriptions": {
    get: operations["issueSubscriptions"];
  };
  "/repos/{owner}/{repo}/issues/{index}/subscriptions/check": {
    get: operations["issueCheckSubscription"];
  };
  "/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}": {
    put: operations["issueAddSubscription"];
    delete: operations["issueDeleteSubscription"];
  };
  "/repos/{owner}/{repo}/issues/{index}/timeline": {
    get: operations["issueGetCommentsAndTimeline"];
  };
  "/repos/{owner}/{repo}/issues/{index}/times": {
    get: operations["issueTrackedTimes"];
    post: operations["issueAddTime"];
    delete: operations["issueResetTime"];
  };
  "/repos/{owner}/{repo}/issues/{index}/times/{id}": {
    delete: operations["issueDeleteTime"];
  };
  "/repos/{owner}/{repo}/keys": {
    get: operations["repoListKeys"];
    post: operations["repoCreateKey"];
  };
  "/repos/{owner}/{repo}/keys/{id}": {
    get: operations["repoGetKey"];
    delete: operations["repoDeleteKey"];
  };
  "/repos/{owner}/{repo}/labels": {
    get: operations["issueListLabels"];
    post: operations["issueCreateLabel"];
  };
  "/repos/{owner}/{repo}/labels/{id}": {
    get: operations["issueGetLabel"];
    delete: operations["issueDeleteLabel"];
    patch: operations["issueEditLabel"];
  };
  "/repos/{owner}/{repo}/languages": {
    get: operations["repoGetLanguages"];
  };
  "/repos/{owner}/{repo}/media/{filepath}": {
    get: operations["repoGetRawFileOrLFS"];
  };
  "/repos/{owner}/{repo}/milestones": {
    get: operations["issueGetMilestonesList"];
    post: operations["issueCreateMilestone"];
  };
  "/repos/{owner}/{repo}/milestones/{id}": {
    get: operations["issueGetMilestone"];
    delete: operations["issueDeleteMilestone"];
    patch: operations["issueEditMilestone"];
  };
  "/repos/{owner}/{repo}/mirror-sync": {
    post: operations["repoMirrorSync"];
  };
  "/repos/{owner}/{repo}/new_pin_allowed": {
    get: operations["repoNewPinAllowed"];
  };
  "/repos/{owner}/{repo}/notifications": {
    get: operations["notifyGetRepoList"];
    put: operations["notifyReadRepoList"];
  };
  "/repos/{owner}/{repo}/pulls": {
    get: operations["repoListPullRequests"];
    post: operations["repoCreatePullRequest"];
  };
  "/repos/{owner}/{repo}/pulls/pinned": {
    get: operations["repoListPinnedPullRequests"];
  };
  "/repos/{owner}/{repo}/pulls/{base}/{head}": {
    get: operations["repoGetPullRequestByBaseHead"];
  };
  "/repos/{owner}/{repo}/pulls/{index}": {
    get: operations["repoGetPullRequest"];
    patch: operations["repoEditPullRequest"];
  };
  "/repos/{owner}/{repo}/pulls/{index}.{diffType}": {
    get: operations["repoDownloadPullDiffOrPatch"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/commits": {
    get: operations["repoGetPullRequestCommits"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/files": {
    get: operations["repoGetPullRequestFiles"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/merge": {
    get: operations["repoPullRequestIsMerged"];
    post: operations["repoMergePullRequest"];
    delete: operations["repoCancelScheduledAutoMerge"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers": {
    post: operations["repoCreatePullReviewRequests"];
    delete: operations["repoDeletePullReviewRequests"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/reviews": {
    get: operations["repoListPullReviews"];
    post: operations["repoCreatePullReview"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}": {
    get: operations["repoGetPullReview"];
    post: operations["repoSubmitPullReview"];
    delete: operations["repoDeletePullReview"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments": {
    get: operations["repoGetPullReviewComments"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals": {
    post: operations["repoDismissPullReview"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals": {
    post: operations["repoUnDismissPullReview"];
  };
  "/repos/{owner}/{repo}/pulls/{index}/update": {
    post: operations["repoUpdatePullRequest"];
  };
  "/repos/{owner}/{repo}/push_mirrors": {
    get: operations["repoListPushMirrors"];
    post: operations["repoAddPushMirror"];
  };
  "/repos/{owner}/{repo}/push_mirrors-sync": {
    post: operations["repoPushMirrorSync"];
  };
  "/repos/{owner}/{repo}/push_mirrors/{name}": {
    get: operations["repoGetPushMirrorByRemoteName"];
    delete: operations["repoDeletePushMirror"];
  };
  "/repos/{owner}/{repo}/raw/{filepath}": {
    get: operations["repoGetRawFile"];
  };
  "/repos/{owner}/{repo}/releases": {
    get: operations["repoListReleases"];
    post: operations["repoCreateRelease"];
  };
  "/repos/{owner}/{repo}/releases/latest": {
    get: operations["repoGetLatestRelease"];
  };
  "/repos/{owner}/{repo}/releases/tags/{tag}": {
    get: operations["repoGetReleaseByTag"];
    delete: operations["repoDeleteReleaseByTag"];
  };
  "/repos/{owner}/{repo}/releases/{id}": {
    get: operations["repoGetRelease"];
    delete: operations["repoDeleteRelease"];
    patch: operations["repoEditRelease"];
  };
  "/repos/{owner}/{repo}/releases/{id}/assets": {
    get: operations["repoListReleaseAttachments"];
    post: operations["repoCreateReleaseAttachment"];
  };
  "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}": {
    get: operations["repoGetReleaseAttachment"];
    delete: operations["repoDeleteReleaseAttachment"];
    patch: operations["repoEditReleaseAttachment"];
  };
  "/repos/{owner}/{repo}/reviewers": {
    get: operations["repoGetReviewers"];
  };
  "/repos/{owner}/{repo}/runners/registration-token": {
    get: operations["repoGetRunnerRegistrationToken"];
  };
  "/repos/{owner}/{repo}/signing-key.gpg": {
    get: operations["repoSigningKey"];
  };
  "/repos/{owner}/{repo}/stargazers": {
    get: operations["repoListStargazers"];
  };
  "/repos/{owner}/{repo}/statuses/{sha}": {
    get: operations["repoListStatuses"];
    post: operations["repoCreateStatus"];
  };
  "/repos/{owner}/{repo}/subscribers": {
    get: operations["repoListSubscribers"];
  };
  "/repos/{owner}/{repo}/subscription": {
    get: operations["userCurrentCheckSubscription"];
    put: operations["userCurrentPutSubscription"];
    delete: operations["userCurrentDeleteSubscription"];
  };
  "/repos/{owner}/{repo}/tags": {
    get: operations["repoListTags"];
    post: operations["repoCreateTag"];
  };
  "/repos/{owner}/{repo}/tags/{tag}": {
    get: operations["repoGetTag"];
    delete: operations["repoDeleteTag"];
  };
  "/repos/{owner}/{repo}/teams": {
    get: operations["repoListTeams"];
  };
  "/repos/{owner}/{repo}/teams/{team}": {
    get: operations["repoCheckTeam"];
    put: operations["repoAddTeam"];
    delete: operations["repoDeleteTeam"];
  };
  "/repos/{owner}/{repo}/times": {
    get: operations["repoTrackedTimes"];
  };
  "/repos/{owner}/{repo}/times/{user}": {
    get: operations["userTrackedTimes"];
  };
  "/repos/{owner}/{repo}/topics": {
    get: operations["repoListTopics"];
    put: operations["repoUpdateTopics"];
  };
  "/repos/{owner}/{repo}/topics/{topic}": {
    put: operations["repoAddTopic"];
    delete: operations["repoDeleteTopic"];
  };
  "/repos/{owner}/{repo}/transfer": {
    post: operations["repoTransfer"];
  };
  "/repos/{owner}/{repo}/transfer/accept": {
    post: operations["acceptRepoTransfer"];
  };
  "/repos/{owner}/{repo}/transfer/reject": {
    post: operations["rejectRepoTransfer"];
  };
  "/repos/{owner}/{repo}/wiki/new": {
    post: operations["repoCreateWikiPage"];
  };
  "/repos/{owner}/{repo}/wiki/page/{pageName}": {
    get: operations["repoGetWikiPage"];
    delete: operations["repoDeleteWikiPage"];
    patch: operations["repoEditWikiPage"];
  };
  "/repos/{owner}/{repo}/wiki/pages": {
    get: operations["repoGetWikiPages"];
  };
  "/repos/{owner}/{repo}/wiki/revisions/{pageName}": {
    get: operations["repoGetWikiPageRevisions"];
  };
  "/repos/{template_owner}/{template_repo}/generate": {
    post: operations["generateRepo"];
  };
  "/repositories/{id}": {
    get: operations["repoGetByID"];
  };
  "/settings/api": {
    get: operations["getGeneralAPISettings"];
  };
  "/settings/attachment": {
    get: operations["getGeneralAttachmentSettings"];
  };
  "/settings/repository": {
    get: operations["getGeneralRepositorySettings"];
  };
  "/settings/ui": {
    get: operations["getGeneralUISettings"];
  };
  "/signing-key.gpg": {
    get: operations["getSigningKey"];
  };
  "/teams/{id}": {
    get: operations["orgGetTeam"];
    delete: operations["orgDeleteTeam"];
    patch: operations["orgEditTeam"];
  };
  "/teams/{id}/activities/feeds": {
    get: operations["orgListTeamActivityFeeds"];
  };
  "/teams/{id}/members": {
    get: operations["orgListTeamMembers"];
  };
  "/teams/{id}/members/{username}": {
    get: operations["orgListTeamMember"];
    put: operations["orgAddTeamMember"];
    delete: operations["orgRemoveTeamMember"];
  };
  "/teams/{id}/repos": {
    get: operations["orgListTeamRepos"];
  };
  "/teams/{id}/repos/{org}/{repo}": {
    get: operations["orgListTeamRepo"];
    put: operations["orgAddTeamRepository"];
    /** This does not delete the repository, it only removes the repository from the team. */
    delete: operations["orgRemoveTeamRepository"];
  };
  "/topics/search": {
    get: operations["topicSearch"];
  };
  "/user": {
    get: operations["userGetCurrent"];
  };
  "/user/actions/runners/registration-token": {
    get: operations["userGetRunnerRegistrationToken"];
  };
  "/user/actions/secrets/{secretname}": {
    put: operations["updateUserSecret"];
    delete: operations["deleteUserSecret"];
  };
  "/user/actions/variables": {
    get: operations["getUserVariablesList"];
  };
  "/user/actions/variables/{variablename}": {
    get: operations["getUserVariable"];
    put: operations["updateUserVariable"];
    post: operations["createUserVariable"];
    delete: operations["deleteUserVariable"];
  };
  "/user/applications/oauth2": {
    get: operations["userGetOauth2Application"];
    post: operations["userCreateOAuth2Application"];
  };
  "/user/applications/oauth2/{id}": {
    get: operations["userGetOAuth2Application"];
    delete: operations["userDeleteOAuth2Application"];
    patch: operations["userUpdateOAuth2Application"];
  };
  "/user/avatar": {
    post: operations["userUpdateAvatar"];
    delete: operations["userDeleteAvatar"];
  };
  "/user/blocks": {
    get: operations["userListBlocks"];
  };
  "/user/blocks/{username}": {
    get: operations["userCheckUserBlock"];
    put: operations["userBlockUser"];
    delete: operations["userUnblockUser"];
  };
  "/user/emails": {
    get: operations["userListEmails"];
    post: operations["userAddEmail"];
    delete: operations["userDeleteEmail"];
  };
  "/user/followers": {
    get: operations["userCurrentListFollowers"];
  };
  "/user/following": {
    get: operations["userCurrentListFollowing"];
  };
  "/user/following/{username}": {
    get: operations["userCurrentCheckFollowing"];
    put: operations["userCurrentPutFollow"];
    delete: operations["userCurrentDeleteFollow"];
  };
  "/user/gpg_key_token": {
    get: operations["getVerificationToken"];
  };
  "/user/gpg_key_verify": {
    post: operations["userVerifyGPGKey"];
  };
  "/user/gpg_keys": {
    get: operations["userCurrentListGPGKeys"];
    post: operations["userCurrentPostGPGKey"];
  };
  "/user/gpg_keys/{id}": {
    get: operations["userCurrentGetGPGKey"];
    delete: operations["userCurrentDeleteGPGKey"];
  };
  "/user/hooks": {
    get: operations["userListHooks"];
    post: operations["userCreateHook"];
  };
  "/user/hooks/{id}": {
    get: operations["userGetHook"];
    delete: operations["userDeleteHook"];
    patch: operations["userEditHook"];
  };
  "/user/keys": {
    get: operations["userCurrentListKeys"];
    post: operations["userCurrentPostKey"];
  };
  "/user/keys/{id}": {
    get: operations["userCurrentGetKey"];
    delete: operations["userCurrentDeleteKey"];
  };
  "/user/orgs": {
    get: operations["orgListCurrentUserOrgs"];
  };
  "/user/repos": {
    get: operations["userCurrentListRepos"];
    post: operations["createCurrentUserRepo"];
  };
  "/user/settings": {
    get: operations["getUserSettings"];
    patch: operations["updateUserSettings"];
  };
  "/user/starred": {
    get: operations["userCurrentListStarred"];
  };
  "/user/starred/{owner}/{repo}": {
    get: operations["userCurrentCheckStarring"];
    put: operations["userCurrentPutStar"];
    delete: operations["userCurrentDeleteStar"];
  };
  "/user/stopwatches": {
    get: operations["userGetStopWatches"];
  };
  "/user/subscriptions": {
    get: operations["userCurrentListSubscriptions"];
  };
  "/user/teams": {
    get: operations["userListTeams"];
  };
  "/user/times": {
    get: operations["userCurrentTrackedTimes"];
  };
  "/users/search": {
    get: operations["userSearch"];
  };
  "/users/{username}": {
    get: operations["userGet"];
  };
  "/users/{username}/activities/feeds": {
    get: operations["userListActivityFeeds"];
  };
  "/users/{username}/followers": {
    get: operations["userListFollowers"];
  };
  "/users/{username}/following": {
    get: operations["userListFollowing"];
  };
  "/users/{username}/following/{target}": {
    get: operations["userCheckFollowing"];
  };
  "/users/{username}/gpg_keys": {
    get: operations["userListGPGKeys"];
  };
  "/users/{username}/heatmap": {
    get: operations["userGetHeatmapData"];
  };
  "/users/{username}/keys": {
    get: operations["userListKeys"];
  };
  "/users/{username}/orgs": {
    get: operations["orgListUserOrgs"];
  };
  "/users/{username}/orgs/{org}/permissions": {
    get: operations["orgGetUserPermissions"];
  };
  "/users/{username}/repos": {
    get: operations["userListRepos"];
  };
  "/users/{username}/starred": {
    get: operations["userListStarred"];
  };
  "/users/{username}/subscriptions": {
    get: operations["userListSubscriptions"];
  };
  "/users/{username}/tokens": {
    get: operations["userGetTokens"];
    post: operations["userCreateToken"];
  };
  "/users/{username}/tokens/{token}": {
    delete: operations["userDeleteAccessToken"];
  };
  "/version": {
    get: operations["getVersion"];
  };
}

export interface definitions {
  /** @description APIError is an api error with a message */
  APIError: {
    message?: string;
    url?: string;
  };
  /** AccessToken represents an API access token. */
  AccessToken: {
    /** Format: int64 */
    id?: number;
    name?: string;
    scopes?: string[];
    sha1?: string;
    token_last_eight?: string;
  };
  /** @description ActionTask represents a ActionTask */
  ActionTask: {
    /** Format: date-time */
    created_at?: string;
    display_title?: string;
    event?: string;
    head_branch?: string;
    head_sha?: string;
    /** Format: int64 */
    id?: number;
    name?: string;
    /** Format: int64 */
    run_number?: number;
    /** Format: date-time */
    run_started_at?: string;
    status?: string;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
    workflow_id?: string;
  };
  /** @description ActionTaskResponse returns a ActionTask */
  ActionTaskResponse: {
    /** Format: int64 */
    total_count?: number;
    workflow_runs?: definitions["ActionTask"][];
  };
  /** @description ActionVariable return value of the query API */
  ActionVariable: {
    /** @description the value of the variable */
    data?: string;
    /** @description the name of the variable */
    name?: string;
    /**
     * Format: int64
     * @description the owner to which the variable belongs
     */
    owner_id?: number;
    /**
     * Format: int64
     * @description the repository to which the variable belongs
     */
    repo_id?: number;
  };
  Activity: {
    act_user?: definitions["User"];
    /** Format: int64 */
    act_user_id?: number;
    comment?: definitions["Comment"];
    /** Format: int64 */
    comment_id?: number;
    content?: string;
    /** Format: date-time */
    created?: string;
    /** Format: int64 */
    id?: number;
    is_private?: boolean;
    op_type?: string;
    ref_name?: string;
    repo?: definitions["Repository"];
    /** Format: int64 */
    repo_id?: number;
    /** Format: int64 */
    user_id?: number;
  };
  /** @description ActivityPub type */
  ActivityPub: {
    "@context"?: string;
  };
  /** @description AddCollaboratorOption options when adding a user as a collaborator of a repository */
  AddCollaboratorOption: {
    permission?: string;
  };
  /** @description AddTimeOption options for adding time to an issue */
  AddTimeOption: {
    /** Format: date-time */
    created?: string;
    /**
     * Format: int64
     * @description time in seconds
     */
    time: number;
    /** @description User who spent the time (optional) */
    user_name?: string;
  };
  /** @description AnnotatedTag represents an annotated tag */
  AnnotatedTag: {
    message?: string;
    object?: definitions["AnnotatedTagObject"];
    sha?: string;
    tag?: string;
    tagger?: definitions["CommitUser"];
    url?: string;
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description AnnotatedTagObject contains meta information of the tag object */
  AnnotatedTagObject: {
    sha?: string;
    type?: string;
    url?: string;
  };
  /** @description Attachment a generic attachment */
  Attachment: {
    browser_download_url?: string;
    /** Format: date-time */
    created_at?: string;
    /** Format: int64 */
    download_count?: number;
    /** Format: int64 */
    id?: number;
    name?: string;
    /** Format: int64 */
    size?: number;
    uuid?: string;
  };
  /** @description Badge represents a user badge */
  Badge: {
    description?: string;
    /** Format: int64 */
    id?: number;
    image_url?: string;
    slug?: string;
  };
  /** @description Branch represents a repository branch */
  Branch: {
    commit?: definitions["PayloadCommit"];
    effective_branch_protection_name?: string;
    enable_status_check?: boolean;
    name?: string;
    protected?: boolean;
    /** Format: int64 */
    required_approvals?: number;
    status_check_contexts?: string[];
    user_can_merge?: boolean;
    user_can_push?: boolean;
  };
  /** @description BranchProtection represents a branch protection for a repository */
  BranchProtection: {
    approvals_whitelist_teams?: string[];
    approvals_whitelist_username?: string[];
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /** @description Deprecated: true */
    branch_name?: string;
    /** Format: date-time */
    created_at?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: string[];
    merge_whitelist_usernames?: string[];
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: string[];
    push_whitelist_usernames?: string[];
    require_signed_commits?: boolean;
    /** Format: int64 */
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: string[];
    unprotected_file_patterns?: string;
    /** Format: date-time */
    updated_at?: string;
  };
  /** @description ChangeFileOperation for creating, updating or deleting a file */
  ChangeFileOperation: {
    /** @description new or updated file content, must be base64 encoded */
    content?: string;
    /** @description old path of the file to move */
    from_path?: string;
    /**
     * @description indicates what to do with the file
     * @enum {string}
     */
    operation: "create" | "update" | "delete";
    /** @description path to the existing or new file */
    path: string;
    /** @description sha is the SHA for the file that already exists, required for update or delete */
    sha?: string;
  };
  /**
   * @description ChangeFilesOptions options for creating, updating or deleting multiple files
   * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
   */
  ChangeFilesOptions: {
    author?: definitions["Identity"];
    /** @description branch (optional) to base this file from. if not given, the default branch is used */
    branch?: string;
    committer?: definitions["Identity"];
    dates?: definitions["CommitDateOptions"];
    /** @description list of file operations */
    files: definitions["ChangeFileOperation"][];
    /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
    message?: string;
    /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
    new_branch?: string;
    /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
    signoff?: boolean;
  };
  /** @description ChangedFile store information about files affected by the pull request */
  ChangedFile: {
    /** Format: int64 */
    additions?: number;
    /** Format: int64 */
    changes?: number;
    contents_url?: string;
    /** Format: int64 */
    deletions?: number;
    filename?: string;
    html_url?: string;
    previous_filename?: string;
    raw_url?: string;
    status?: string;
  };
  /** @description CombinedStatus holds the combined state of several statuses for a single commit */
  CombinedStatus: {
    commit_url?: string;
    repository?: definitions["Repository"];
    sha?: string;
    state?: definitions["CommitStatusState"];
    statuses?: definitions["CommitStatus"][];
    /** Format: int64 */
    total_count?: number;
    url?: string;
  };
  /** @description Comment represents a comment on a commit or issue */
  Comment: {
    assets?: definitions["Attachment"][];
    body?: string;
    /** Format: date-time */
    created_at?: string;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    issue_url?: string;
    original_author?: string;
    /** Format: int64 */
    original_author_id?: number;
    pull_request_url?: string;
    /** Format: date-time */
    updated_at?: string;
    user?: definitions["User"];
  };
  /** Commit contains information generated from a Git commit. */
  Commit: {
    author?: definitions["User"];
    commit?: definitions["RepoCommit"];
    committer?: definitions["User"];
    /** Format: date-time */
    created?: string;
    files?: definitions["CommitAffectedFiles"][];
    html_url?: string;
    parents?: definitions["CommitMeta"][];
    sha?: string;
    stats?: definitions["CommitStats"];
    url?: string;
  };
  /** @description CommitAffectedFiles store information about files affected by the commit */
  CommitAffectedFiles: {
    filename?: string;
    status?: string;
  };
  /** @description CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE */
  CommitDateOptions: {
    /** Format: date-time */
    author?: string;
    /** Format: date-time */
    committer?: string;
  };
  /** CommitMeta contains meta information of a commit in terms of API. */
  CommitMeta: {
    /** Format: date-time */
    created?: string;
    sha?: string;
    url?: string;
  };
  /** @description CommitStats is statistics for a RepoCommit */
  CommitStats: {
    /** Format: int64 */
    additions?: number;
    /** Format: int64 */
    deletions?: number;
    /** Format: int64 */
    total?: number;
  };
  /** @description CommitStatus holds a single status of a single Commit */
  CommitStatus: {
    context?: string;
    /** Format: date-time */
    created_at?: string;
    creator?: definitions["User"];
    description?: string;
    /** Format: int64 */
    id?: number;
    status?: definitions["CommitStatusState"];
    target_url?: string;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
  };
  /**
   * @description CommitStatusState holds the state of a CommitStatus
   * It can be "pending", "success", "error" and "failure"
   */
  CommitStatusState: string;
  /** CommitUser contains information of a user in the context of a commit. */
  CommitUser: {
    date?: string;
    /** Format: email */
    email?: string;
    name?: string;
  };
  /** Compare represents a comparison between two commits. */
  Compare: {
    commits?: definitions["Commit"][];
    /** Format: int64 */
    total_commits?: number;
  };
  /** @description ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content */
  ContentsResponse: {
    _links?: definitions["FileLinksResponse"];
    /** @description `content` is populated when `type` is `file`, otherwise null */
    content?: string;
    download_url?: string;
    /** @description `encoding` is populated when `type` is `file`, otherwise null */
    encoding?: string;
    git_url?: string;
    html_url?: string;
    last_commit_sha?: string;
    name?: string;
    path?: string;
    sha?: string;
    /** Format: int64 */
    size?: number;
    /** @description `submodule_git_url` is populated when `type` is `submodule`, otherwise null */
    submodule_git_url?: string;
    /** @description `target` is populated when `type` is `symlink`, otherwise null */
    target?: string;
    /** @description `type` will be `file`, `dir`, `symlink`, or `submodule` */
    type?: string;
    url?: string;
  };
  /** @description CreateAccessTokenOption options when create access token */
  CreateAccessTokenOption: {
    name: string;
    scopes?: string[];
  };
  /** @description CreateBranchProtectionOption options for creating a branch protection */
  CreateBranchProtectionOption: {
    approvals_whitelist_teams?: string[];
    approvals_whitelist_username?: string[];
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /** @description Deprecated: true */
    branch_name?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: string[];
    merge_whitelist_usernames?: string[];
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: string[];
    push_whitelist_usernames?: string[];
    require_signed_commits?: boolean;
    /** Format: int64 */
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: string[];
    unprotected_file_patterns?: string;
  };
  /** @description CreateBranchRepoOption options when creating a branch in a repository */
  CreateBranchRepoOption: {
    /** @description Name of the branch to create */
    new_branch_name: string;
    /**
     * @description Deprecated: true
     * Name of the old branch to create from
     */
    old_branch_name?: string;
    /** @description Name of the old branch/tag/commit to create from */
    old_ref_name?: string;
  };
  /** @description CreateEmailOption options when creating email addresses */
  CreateEmailOption: {
    /** @description email addresses to add */
    emails?: string[];
  };
  /**
   * @description CreateFileOptions options for creating files
   * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
   */
  CreateFileOptions: {
    author?: definitions["Identity"];
    /** @description branch (optional) to base this file from. if not given, the default branch is used */
    branch?: string;
    committer?: definitions["Identity"];
    /** @description content must be base64 encoded */
    content: string;
    dates?: definitions["CommitDateOptions"];
    /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
    message?: string;
    /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
    new_branch?: string;
    /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
    signoff?: boolean;
  };
  /** @description CreateForkOption options for creating a fork */
  CreateForkOption: {
    /** @description name of the forked repository */
    name?: string;
    /** @description organization name, if forking into an organization */
    organization?: string;
  };
  /** @description CreateGPGKeyOption options create user GPG key */
  CreateGPGKeyOption: {
    /** @description An armored GPG key to add */
    armored_public_key: string;
    armored_signature?: string;
  };
  /** @description CreateHookOption options when create a hook */
  CreateHookOption: {
    /** @default false */
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config: definitions["CreateHookOptionConfig"];
    events?: string[];
    /** @enum {string} */
    type:
      | "dingtalk"
      | "discord"
      | "gitea"
      | "gogs"
      | "msteams"
      | "slack"
      | "telegram"
      | "feishu"
      | "wechatwork"
      | "packagist";
  };
  /**
   * @description CreateHookOptionConfig has all config options in it
   * required are "content_type" and "url" Required
   */
  CreateHookOptionConfig: { [key: string]: string };
  /** @description CreateIssueCommentOption options for creating a comment on an issue */
  CreateIssueCommentOption: {
    body: string;
  };
  /** @description CreateIssueOption options to create one issue */
  CreateIssueOption: {
    /** @description deprecated */
    assignee?: string;
    assignees?: string[];
    body?: string;
    closed?: boolean;
    /** Format: date-time */
    due_date?: string;
    /** @description list of label ids */
    labels?: number[];
    /**
     * Format: int64
     * @description milestone id
     */
    milestone?: number;
    ref?: string;
    title: string;
  };
  /** @description CreateKeyOption options when creating a key */
  CreateKeyOption: {
    /** @description An armored SSH key to add */
    key: string;
    /** @description Describe if the key has only read access or read/write */
    read_only?: boolean;
    /** @description Title of the key to add */
    title: string;
  };
  /** @description CreateLabelOption options for creating a label */
  CreateLabelOption: {
    /** @example #00aabb */
    color: string;
    description?: string;
    /** @example false */
    exclusive?: boolean;
    /** @example false */
    is_archived?: boolean;
    name: string;
  };
  /** @description CreateMilestoneOption options for creating a milestone */
  CreateMilestoneOption: {
    description?: string;
    /** Format: date-time */
    due_on?: string;
    /** @enum {string} */
    state?: "open" | "closed";
    title?: string;
  };
  /** @description CreateOAuth2ApplicationOptions holds options to create an oauth2 application */
  CreateOAuth2ApplicationOptions: {
    confidential_client?: boolean;
    name?: string;
    redirect_uris?: string[];
  };
  /** @description CreateOrUpdateSecretOption options when creating or updating secret */
  CreateOrUpdateSecretOption: {
    /** @description Data of the secret to update */
    data: string;
  };
  /** @description CreateOrgOption options for creating an organization */
  CreateOrgOption: {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    username: string;
    /**
     * @description possible values are `public` (default), `limited` or `private`
     * @enum {string}
     */
    visibility?: "public" | "limited" | "private";
    website?: string;
  };
  /** @description CreatePullRequestOption options when creating a pull request */
  CreatePullRequestOption: {
    assignee?: string;
    assignees?: string[];
    base?: string;
    body?: string;
    /** Format: date-time */
    due_date?: string;
    head?: string;
    labels?: number[];
    /** Format: int64 */
    milestone?: number;
    title?: string;
  };
  /** @description CreatePullReviewComment represent a review comment for creation api */
  CreatePullReviewComment: {
    body?: string;
    /**
     * Format: int64
     * @description if comment to new file line or 0
     */
    new_position?: number;
    /**
     * Format: int64
     * @description if comment to old file line or 0
     */
    old_position?: number;
    /** @description the tree path */
    path?: string;
  };
  /** @description CreatePullReviewOptions are options to create a pull review */
  CreatePullReviewOptions: {
    body?: string;
    comments?: definitions["CreatePullReviewComment"][];
    commit_id?: string;
    event?: definitions["ReviewStateType"];
  };
  /** CreatePushMirrorOption represents need information to create a push mirror of a repository. */
  CreatePushMirrorOption: {
    interval?: string;
    remote_address?: string;
    remote_password?: string;
    remote_username?: string;
    sync_on_commit?: boolean;
  };
  /** @description CreateReleaseOption options when creating a release */
  CreateReleaseOption: {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name: string;
    target_commitish?: string;
  };
  /** @description CreateRepoOption options when creating repository */
  CreateRepoOption: {
    /** @description Whether the repository should be auto-initialized? */
    auto_init?: boolean;
    /** @description DefaultBranch of the repository (used when initializes and in template) */
    default_branch?: string;
    /** @description Description of the repository to create */
    description?: string;
    /** @description Gitignores to use */
    gitignores?: string;
    /** @description Label-Set to use */
    issue_labels?: string;
    /** @description License to use */
    license?: string;
    /** @description Name of the repository to create */
    name: string;
    /**
     * @description ObjectFormatName of the underlying git repository
     * @enum {string}
     */
    object_format_name?: "sha1" | "sha256";
    /** @description Whether the repository is private */
    private?: boolean;
    /** @description Readme of the repository to create */
    readme?: string;
    /** @description Whether the repository is template */
    template?: boolean;
    /**
     * @description TrustModel of the repository
     * @enum {string}
     */
    trust_model?:
      | "default"
      | "collaborator"
      | "committer"
      | "collaboratorcommitter";
  };
  /** @description CreateStatusOption holds the information needed to create a new CommitStatus for a Commit */
  CreateStatusOption: {
    context?: string;
    description?: string;
    state?: definitions["CommitStatusState"];
    target_url?: string;
  };
  /** @description CreateTagOption options when creating a tag */
  CreateTagOption: {
    message?: string;
    tag_name: string;
    target?: string;
  };
  /** @description CreateTeamOption options for creating a team */
  CreateTeamOption: {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    /** @enum {string} */
    permission?: "read" | "write" | "admin";
    /**
     * @example [
     *   "repo.actions",
     *   "repo.code",
     *   "repo.issues",
     *   "repo.ext_issues",
     *   "repo.wiki",
     *   "repo.ext_wiki",
     *   "repo.pulls",
     *   "repo.releases",
     *   "repo.projects",
     *   "repo.ext_wiki"
     * ]
     */
    units?: string[];
    /** @example {"repo.actions","repo.packages","repo.code":"read","repo.issues":"write","repo.ext_issues":"none","repo.wiki":"admin","repo.pulls":"owner","repo.releases":"none","repo.projects":"none","repo.ext_wiki":"none"} */
    units_map?: { [key: string]: string };
  };
  /** @description CreateUserOption create user options */
  CreateUserOption: {
    /**
     * Format: date-time
     * @description For explicitly setting the user creation timestamp. Useful when users are
     * migrated from other systems. When omitted, the user's creation timestamp
     * will be set to "now".
     */
    created_at?: string;
    /** Format: email */
    email: string;
    full_name?: string;
    login_name?: string;
    must_change_password?: boolean;
    password?: string;
    restricted?: boolean;
    send_notify?: boolean;
    /** Format: int64 */
    source_id?: number;
    username: string;
    visibility?: string;
  };
  /** @description CreateVariableOption the option when creating variable */
  CreateVariableOption: {
    /** @description Value of the variable to create */
    value: string;
  };
  /** @description CreateWikiPageOptions form for creating wiki */
  CreateWikiPageOptions: {
    /** @description content must be base64 encoded */
    content_base64?: string;
    /** @description optional commit message summarizing the change */
    message?: string;
    /** @description page title. leave empty to keep unchanged */
    title?: string;
  };
  /** @description Cron represents a Cron task */
  Cron: {
    /** Format: int64 */
    exec_times?: number;
    name?: string;
    /** Format: date-time */
    next?: string;
    /** Format: date-time */
    prev?: string;
    schedule?: string;
  };
  /** @description DeleteEmailOption options when deleting email addresses */
  DeleteEmailOption: {
    /** @description email addresses to delete */
    emails?: string[];
  };
  /**
   * @description DeleteFileOptions options for deleting files (used for other File structs below)
   * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
   */
  DeleteFileOptions: {
    author?: definitions["Identity"];
    /** @description branch (optional) to base this file from. if not given, the default branch is used */
    branch?: string;
    committer?: definitions["Identity"];
    dates?: definitions["CommitDateOptions"];
    /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
    message?: string;
    /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
    new_branch?: string;
    /** @description sha is the SHA for the file that already exists */
    sha: string;
    /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
    signoff?: boolean;
  };
  /** @description DeployKey a deploy key */
  DeployKey: {
    /** Format: date-time */
    created_at?: string;
    fingerprint?: string;
    /** Format: int64 */
    id?: number;
    key?: string;
    /** Format: int64 */
    key_id?: number;
    read_only?: boolean;
    repository?: definitions["Repository"];
    title?: string;
    url?: string;
  };
  /** @description DismissPullReviewOptions are options to dismiss a pull review */
  DismissPullReviewOptions: {
    message?: string;
    priors?: boolean;
  };
  /** @description EditAttachmentOptions options for editing attachments */
  EditAttachmentOptions: {
    name?: string;
  };
  /** @description EditBranchProtectionOption options for editing a branch protection */
  EditBranchProtectionOption: {
    approvals_whitelist_teams?: string[];
    approvals_whitelist_username?: string[];
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: string[];
    merge_whitelist_usernames?: string[];
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: string[];
    push_whitelist_usernames?: string[];
    require_signed_commits?: boolean;
    /** Format: int64 */
    required_approvals?: number;
    status_check_contexts?: string[];
    unprotected_file_patterns?: string;
  };
  /** @description EditDeadlineOption options for creating a deadline */
  EditDeadlineOption: {
    /** Format: date-time */
    due_date: string;
  };
  /** @description EditGitHookOption options when modifying one Git hook */
  EditGitHookOption: {
    content?: string;
  };
  /** @description EditHookOption options when modify one hook */
  EditHookOption: {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config?: { [key: string]: string };
    events?: string[];
  };
  /** @description EditIssueCommentOption options for editing a comment */
  EditIssueCommentOption: {
    body: string;
  };
  /** @description EditIssueOption options for editing an issue */
  EditIssueOption: {
    /** @description deprecated */
    assignee?: string;
    assignees?: string[];
    body?: string;
    /** Format: date-time */
    due_date?: string;
    /** Format: int64 */
    milestone?: number;
    ref?: string;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
  };
  /** @description EditLabelOption options for editing a label */
  EditLabelOption: {
    /** @example #00aabb */
    color?: string;
    description?: string;
    /** @example false */
    exclusive?: boolean;
    /** @example false */
    is_archived?: boolean;
    name?: string;
  };
  /** @description EditMilestoneOption options for editing a milestone */
  EditMilestoneOption: {
    description?: string;
    /** Format: date-time */
    due_on?: string;
    state?: string;
    title?: string;
  };
  /** @description EditOrgOption options for editing an organization */
  EditOrgOption: {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    /**
     * @description possible values are `public`, `limited` or `private`
     * @enum {string}
     */
    visibility?: "public" | "limited" | "private";
    website?: string;
  };
  /** @description EditPullRequestOption options when modify pull request */
  EditPullRequestOption: {
    allow_maintainer_edit?: boolean;
    assignee?: string;
    assignees?: string[];
    base?: string;
    body?: string;
    /** Format: date-time */
    due_date?: string;
    labels?: number[];
    /** Format: int64 */
    milestone?: number;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
  };
  /** @description EditReactionOption contain the reaction type */
  EditReactionOption: {
    content?: string;
  };
  /** @description EditReleaseOption options when editing a release */
  EditReleaseOption: {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name?: string;
    target_commitish?: string;
  };
  /** @description EditRepoOption options when editing a repository's properties */
  EditRepoOption: {
    /** @description either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging. */
    allow_fast_forward_only_merge?: boolean;
    /** @description either `true` to allow mark pr as merged manually, or `false` to prevent it. */
    allow_manual_merge?: boolean;
    /** @description either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits. */
    allow_merge_commits?: boolean;
    /** @description either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging. */
    allow_rebase?: boolean;
    /** @description either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits. */
    allow_rebase_explicit?: boolean;
    /** @description either `true` to allow updating pull request branch by rebase, or `false` to prevent it. */
    allow_rebase_update?: boolean;
    /** @description either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging. */
    allow_squash_merge?: boolean;
    /** @description set to `true` to archive this repository. */
    archived?: boolean;
    /** @description either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur. */
    autodetect_manual_merge?: boolean;
    /** @description set to `true` to allow edits from maintainers by default */
    default_allow_maintainer_edit?: boolean;
    /** @description sets the default branch for this repository. */
    default_branch?: string;
    /** @description set to `true` to delete pr branch after merge by default */
    default_delete_branch_after_merge?: boolean;
    /** @description set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", or "fast-forward-only". */
    default_merge_style?: string;
    /** @description a short description of the repository. */
    description?: string;
    /** @description enable prune - remove obsolete remote-tracking references */
    enable_prune?: boolean;
    external_tracker?: definitions["ExternalTracker"];
    external_wiki?: definitions["ExternalWiki"];
    /** @description either `true` to enable actions unit, or `false` to disable them. */
    has_actions?: boolean;
    /** @description either `true` to enable issues for this repository or `false` to disable them. */
    has_issues?: boolean;
    /** @description either `true` to enable packages unit, or `false` to disable them. */
    has_packages?: boolean;
    /** @description either `true` to enable project unit, or `false` to disable them. */
    has_projects?: boolean;
    /** @description either `true` to allow pull requests, or `false` to prevent pull request. */
    has_pull_requests?: boolean;
    /** @description either `true` to enable releases unit, or `false` to disable them. */
    has_releases?: boolean;
    /** @description either `true` to enable the wiki for this repository or `false` to disable it. */
    has_wiki?: boolean;
    /** @description either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace. */
    ignore_whitespace_conflicts?: boolean;
    internal_tracker?: definitions["InternalTracker"];
    /** @description set to a string like `8h30m0s` to set the mirror interval time */
    mirror_interval?: string;
    /** @description name of the repository */
    name?: string;
    /**
     * @description either `true` to make the repository private or `false` to make it public.
     * Note: you will get a 422 error if the organization restricts changing repository visibility to organization
     * owners and a non-owner tries to change the value of private.
     */
    private?: boolean;
    /** @description `repo` to only allow repo-level projects, `owner` to only allow owner projects, `all` to allow both. */
    projects_mode?: string;
    /** @description either `true` to make this repository a template or `false` to make it a normal repository */
    template?: boolean;
    /** @description a URL with more information about the repository. */
    website?: string;
  };
  /** @description EditTeamOption options for editing a team */
  EditTeamOption: {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    /** @enum {string} */
    permission?: "read" | "write" | "admin";
    /**
     * @example [
     *   "repo.code",
     *   "repo.issues",
     *   "repo.ext_issues",
     *   "repo.wiki",
     *   "repo.pulls",
     *   "repo.releases",
     *   "repo.projects",
     *   "repo.ext_wiki"
     * ]
     */
    units?: string[];
    /**
     * @example {
     *   "repo.code": "read",
     *   "repo.ext_issues": "none",
     *   "repo.ext_wiki": "none",
     *   "repo.issues": "write",
     *   "repo.projects": "none",
     *   "repo.pulls": "owner",
     *   "repo.releases": "none",
     *   "repo.wiki": "admin"
     * }
     */
    units_map?: { [key: string]: string };
  };
  /** @description EditUserOption edit user options */
  EditUserOption: {
    active?: boolean;
    admin?: boolean;
    allow_create_organization?: boolean;
    allow_git_hook?: boolean;
    allow_import_local?: boolean;
    description?: string;
    /** Format: email */
    email?: string;
    full_name?: string;
    location?: string;
    login_name: string;
    /** Format: int64 */
    max_repo_creation?: number;
    must_change_password?: boolean;
    password?: string;
    prohibit_login?: boolean;
    restricted?: boolean;
    /** Format: int64 */
    source_id: number;
    visibility?: string;
    website?: string;
  };
  /** @description Email an email address belonging to a user */
  Email: {
    /** Format: email */
    email?: string;
    primary?: boolean;
    /** Format: int64 */
    user_id?: number;
    username?: string;
    verified?: boolean;
  };
  /** @description ExternalTracker represents settings for external tracker */
  ExternalTracker: {
    /** @description External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index. */
    external_tracker_format?: string;
    /** @description External Issue Tracker issue regular expression */
    external_tracker_regexp_pattern?: string;
    /** @description External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp` */
    external_tracker_style?: string;
    /** @description URL of external issue tracker. */
    external_tracker_url?: string;
  };
  /** @description ExternalWiki represents setting for external wiki */
  ExternalWiki: {
    /** @description URL of external wiki. */
    external_wiki_url?: string;
  };
  /** FileCommitResponse contains information generated from a Git commit for a repo's file. */
  FileCommitResponse: {
    author?: definitions["CommitUser"];
    committer?: definitions["CommitUser"];
    /** Format: date-time */
    created?: string;
    html_url?: string;
    message?: string;
    parents?: definitions["CommitMeta"][];
    sha?: string;
    tree?: definitions["CommitMeta"];
    url?: string;
  };
  /** @description FileDeleteResponse contains information about a repo's file that was deleted */
  FileDeleteResponse: {
    commit?: definitions["FileCommitResponse"];
    content?: unknown;
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description FileLinksResponse contains the links for a repo's file */
  FileLinksResponse: {
    git?: string;
    html?: string;
    self?: string;
  };
  /** @description FileResponse contains information about a repo's file */
  FileResponse: {
    commit?: definitions["FileCommitResponse"];
    content?: definitions["ContentsResponse"];
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description FilesResponse contains information about multiple files from a repo */
  FilesResponse: {
    commit?: definitions["FileCommitResponse"];
    files?: definitions["ContentsResponse"][];
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description GPGKey a user GPG key to sign commit and tag in repository */
  GPGKey: {
    can_certify?: boolean;
    can_encrypt_comms?: boolean;
    can_encrypt_storage?: boolean;
    can_sign?: boolean;
    /** Format: date-time */
    created_at?: string;
    emails?: definitions["GPGKeyEmail"][];
    /** Format: date-time */
    expires_at?: string;
    /** Format: int64 */
    id?: number;
    key_id?: string;
    primary_key_id?: string;
    public_key?: string;
    subkeys?: definitions["GPGKey"][];
    verified?: boolean;
  };
  /** @description GPGKeyEmail an email attached to a GPGKey */
  GPGKeyEmail: {
    email?: string;
    verified?: boolean;
  };
  /** @description GeneralAPISettings contains global api settings exposed by it */
  GeneralAPISettings: {
    /** Format: int64 */
    default_git_trees_per_page?: number;
    /** Format: int64 */
    default_max_blob_size?: number;
    /** Format: int64 */
    default_paging_num?: number;
    /** Format: int64 */
    max_response_items?: number;
  };
  /** @description GeneralAttachmentSettings contains global Attachment settings exposed by API */
  GeneralAttachmentSettings: {
    allowed_types?: string;
    enabled?: boolean;
    /** Format: int64 */
    max_files?: number;
    /** Format: int64 */
    max_size?: number;
  };
  /** @description GeneralRepoSettings contains global repository settings exposed by API */
  GeneralRepoSettings: {
    http_git_disabled?: boolean;
    lfs_disabled?: boolean;
    migrations_disabled?: boolean;
    mirrors_disabled?: boolean;
    stars_disabled?: boolean;
    time_tracking_disabled?: boolean;
  };
  /** @description GeneralUISettings contains global ui settings exposed by API */
  GeneralUISettings: {
    allowed_reactions?: string[];
    custom_emojis?: string[];
    default_theme?: string;
  };
  /** @description GenerateRepoOption options when creating repository using a template */
  GenerateRepoOption: {
    /** @description include avatar of the template repo */
    avatar?: boolean;
    /** @description Default branch of the new repository */
    default_branch?: string;
    /** @description Description of the repository to create */
    description?: string;
    /** @description include git content of default branch in template repo */
    git_content?: boolean;
    /** @description include git hooks in template repo */
    git_hooks?: boolean;
    /** @description include labels in template repo */
    labels?: boolean;
    /** @description Name of the repository to create */
    name: string;
    /** @description The organization or person who will own the new repository */
    owner: string;
    /** @description Whether the repository is private */
    private?: boolean;
    /** @description include protected branches in template repo */
    protected_branch?: boolean;
    /** @description include topics in template repo */
    topics?: boolean;
    /** @description include webhooks in template repo */
    webhooks?: boolean;
  };
  /** @description GitBlobResponse represents a git blob */
  GitBlobResponse: {
    content?: string;
    encoding?: string;
    sha?: string;
    /** Format: int64 */
    size?: number;
    url?: string;
  };
  /** @description GitEntry represents a git tree */
  GitEntry: {
    mode?: string;
    path?: string;
    sha?: string;
    /** Format: int64 */
    size?: number;
    type?: string;
    url?: string;
  };
  /** @description GitHook represents a Git repository hook */
  GitHook: {
    content?: string;
    is_active?: boolean;
    name?: string;
  };
  /** GitObject represents a Git object. */
  GitObject: {
    sha?: string;
    type?: string;
    url?: string;
  };
  /** @description GitTreeResponse returns a git tree */
  GitTreeResponse: {
    /** Format: int64 */
    page?: number;
    sha?: string;
    /** Format: int64 */
    total_count?: number;
    tree?: definitions["GitEntry"][];
    truncated?: boolean;
    url?: string;
  };
  /** @description GitignoreTemplateInfo name and text of a gitignore template */
  GitignoreTemplateInfo: {
    name?: string;
    source?: string;
  };
  /** @description Hook a hook is a web hook when one repository changed */
  Hook: {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config?: { [key: string]: string };
    /** Format: date-time */
    created_at?: string;
    events?: string[];
    /** Format: int64 */
    id?: number;
    type?: string;
    /** Format: date-time */
    updated_at?: string;
  };
  /** @description Identity for a person's identity like an author or committer */
  Identity: {
    /** Format: email */
    email?: string;
    name?: string;
  };
  /** @description InternalTracker represents settings for internal tracker */
  InternalTracker: {
    /** @description Let only contributors track time (Built-in issue tracker) */
    allow_only_contributors_to_track_time?: boolean;
    /** @description Enable dependencies for issues and pull requests (Built-in issue tracker) */
    enable_issue_dependencies?: boolean;
    /** @description Enable time tracking (Built-in issue tracker) */
    enable_time_tracker?: boolean;
  };
  /** @description Issue represents an issue in a repository */
  Issue: {
    assets?: definitions["Attachment"][];
    assignee?: definitions["User"];
    assignees?: definitions["User"][];
    body?: string;
    /** Format: date-time */
    closed_at?: string;
    /** Format: int64 */
    comments?: number;
    /** Format: date-time */
    created_at?: string;
    /** Format: date-time */
    due_date?: string;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    is_locked?: boolean;
    labels?: definitions["Label"][];
    milestone?: definitions["Milestone"];
    /** Format: int64 */
    number?: number;
    original_author?: string;
    /** Format: int64 */
    original_author_id?: number;
    /** Format: int64 */
    pin_order?: number;
    pull_request?: definitions["PullRequestMeta"];
    ref?: string;
    repository?: definitions["RepositoryMeta"];
    state?: definitions["StateType"];
    title?: string;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
    user?: definitions["User"];
  };
  IssueConfig: {
    blank_issues_enabled?: boolean;
    contact_links?: definitions["IssueConfigContactLink"][];
  };
  IssueConfigContactLink: {
    about?: string;
    name?: string;
    url?: string;
  };
  IssueConfigValidation: {
    message?: string;
    valid?: boolean;
  };
  /** @description IssueDeadline represents an issue deadline */
  IssueDeadline: {
    /** Format: date-time */
    due_date?: string;
  };
  /** @description IssueFormField represents a form field */
  IssueFormField: {
    attributes?: { [key: string]: unknown };
    id?: string;
    type?: definitions["IssueFormFieldType"];
    validations?: { [key: string]: unknown };
    visible?: definitions["IssueFormFieldVisible"][];
  };
  /** IssueFormFieldType defines issue form field type, can be "markdown", "textarea", "input", "dropdown" or "checkboxes" */
  IssueFormFieldType: string;
  /** @description IssueFormFieldVisible defines issue form field visible */
  IssueFormFieldVisible: string;
  /** @description IssueLabelsOption a collection of labels */
  IssueLabelsOption: {
    /**
     * @description Labels can be a list of integers representing label IDs
     * or a list of strings representing label names
     */
    labels?: unknown[];
  };
  /** @description IssueMeta basic issue information */
  IssueMeta: {
    /** Format: int64 */
    index?: number;
    owner?: string;
    repo?: string;
  };
  /** @description IssueTemplate represents an issue template for a repository */
  IssueTemplate: {
    about?: string;
    body?: definitions["IssueFormField"][];
    content?: string;
    file_name?: string;
    labels?: definitions["IssueTemplateLabels"];
    name?: string;
    ref?: string;
    title?: string;
  };
  IssueTemplateLabels: string[];
  /** @description Label a label to an issue or a pr */
  Label: {
    /** @example 00aabb */
    color?: string;
    description?: string;
    /** @example false */
    exclusive?: boolean;
    /** Format: int64 */
    id?: number;
    /** @example false */
    is_archived?: boolean;
    name?: string;
    url?: string;
  };
  /** @description LabelTemplate info of a Label template */
  LabelTemplate: {
    /** @example 00aabb */
    color?: string;
    description?: string;
    /** @example false */
    exclusive?: boolean;
    name?: string;
  };
  /** @description LicensesInfo contains information about a License */
  LicenseTemplateInfo: {
    body?: string;
    implementation?: string;
    key?: string;
    name?: string;
    url?: string;
  };
  /** @description LicensesListEntry is used for the API */
  LicensesTemplateListEntry: {
    key?: string;
    name?: string;
    url?: string;
  };
  /** @description MarkdownOption markdown options */
  MarkdownOption: {
    /**
     * @description Context to render
     *
     * in: body
     */
    Context?: string;
    /**
     * @description Mode to render (comment, gfm, markdown)
     *
     * in: body
     */
    Mode?: string;
    /**
     * @description Text markdown to render
     *
     * in: body
     */
    Text?: string;
    /**
     * @description Is it a wiki page ?
     *
     * in: body
     */
    Wiki?: boolean;
  };
  /** @description MarkupOption markup options */
  MarkupOption: {
    /**
     * @description Context to render
     *
     * in: body
     */
    Context?: string;
    /**
     * @description File path for detecting extension in file mode
     *
     * in: body
     */
    FilePath?: string;
    /**
     * @description Mode to render (comment, gfm, markdown, file)
     *
     * in: body
     */
    Mode?: string;
    /**
     * @description Text markup to render
     *
     * in: body
     */
    Text?: string;
    /**
     * @description Is it a wiki page ?
     *
     * in: body
     */
    Wiki?: boolean;
  };
  /** @description MergePullRequestForm form for merging Pull Request */
  MergePullRequestOption: {
    /** @enum {string} */
    Do:
      | "merge"
      | "rebase"
      | "rebase-merge"
      | "squash"
      | "fast-forward-only"
      | "manually-merged";
    MergeCommitID?: string;
    MergeMessageField?: string;
    MergeTitleField?: string;
    delete_branch_after_merge?: boolean;
    force_merge?: boolean;
    head_commit_id?: string;
    merge_when_checks_succeed?: boolean;
  };
  /**
   * @description MigrateRepoOptions options for migrating repository's
   * this is used to interact with api v1
   */
  MigrateRepoOptions: {
    auth_password?: string;
    auth_token?: string;
    auth_username?: string;
    clone_addr: string;
    description?: string;
    issues?: boolean;
    labels?: boolean;
    lfs?: boolean;
    lfs_endpoint?: string;
    milestones?: boolean;
    mirror?: boolean;
    mirror_interval?: string;
    private?: boolean;
    pull_requests?: boolean;
    releases?: boolean;
    repo_name: string;
    /** @description Name of User or Organisation who will own Repo after migration */
    repo_owner?: string;
    /** @enum {string} */
    service?:
      | "git"
      | "github"
      | "gitea"
      | "gitlab"
      | "gogs"
      | "onedev"
      | "gitbucket"
      | "codebase";
    /**
     * Format: int64
     * @description deprecated (only for backwards compatibility)
     */
    uid?: number;
    wiki?: boolean;
  };
  /** @description Milestone milestone is a collection of issues on one repository */
  Milestone: {
    /** Format: date-time */
    closed_at?: string;
    /** Format: int64 */
    closed_issues?: number;
    /** Format: date-time */
    created_at?: string;
    description?: string;
    /** Format: date-time */
    due_on?: string;
    /** Format: int64 */
    id?: number;
    /** Format: int64 */
    open_issues?: number;
    state?: definitions["StateType"];
    title?: string;
    /** Format: date-time */
    updated_at?: string;
  };
  /** @description NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed */
  NewIssuePinsAllowed: {
    issues?: boolean;
    pull_requests?: boolean;
  };
  /** @description NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks */
  NodeInfo: {
    metadata?: { [key: string]: unknown };
    openRegistrations?: boolean;
    protocols?: string[];
    services?: definitions["NodeInfoServices"];
    software?: definitions["NodeInfoSoftware"];
    usage?: definitions["NodeInfoUsage"];
    version?: string;
  };
  /** @description NodeInfoServices contains the third party sites this server can connect to via their application API */
  NodeInfoServices: {
    inbound?: string[];
    outbound?: string[];
  };
  /** @description NodeInfoSoftware contains Metadata about server software in use */
  NodeInfoSoftware: {
    homepage?: string;
    name?: string;
    repository?: string;
    version?: string;
  };
  /** @description NodeInfoUsage contains usage statistics for this server */
  NodeInfoUsage: {
    /** Format: int64 */
    localComments?: number;
    /** Format: int64 */
    localPosts?: number;
    users?: definitions["NodeInfoUsageUsers"];
  };
  /** @description NodeInfoUsageUsers contains statistics about the users of this server */
  NodeInfoUsageUsers: {
    /** Format: int64 */
    activeHalfyear?: number;
    /** Format: int64 */
    activeMonth?: number;
    /** Format: int64 */
    total?: number;
  };
  /** @description Note contains information related to a git note */
  Note: {
    commit?: definitions["Commit"];
    message?: string;
  };
  /** @description NotificationCount number of unread notifications */
  NotificationCount: {
    /** Format: int64 */
    new?: number;
  };
  /** @description NotificationSubject contains the notification subject (Issue/Pull/Commit) */
  NotificationSubject: {
    html_url?: string;
    latest_comment_html_url?: string;
    latest_comment_url?: string;
    state?: definitions["StateType"];
    title?: string;
    type?: definitions["NotifySubjectType"];
    url?: string;
  };
  /** @description NotificationThread expose Notification on API */
  NotificationThread: {
    /** Format: int64 */
    id?: number;
    pinned?: boolean;
    repository?: definitions["Repository"];
    subject?: definitions["NotificationSubject"];
    unread?: boolean;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
  };
  /** @description NotifySubjectType represent type of notification subject */
  NotifySubjectType: string;
  /** OAuth2Application represents an OAuth2 application. */
  OAuth2Application: {
    client_id?: string;
    client_secret?: string;
    confidential_client?: boolean;
    /** Format: date-time */
    created?: string;
    /** Format: int64 */
    id?: number;
    name?: string;
    redirect_uris?: string[];
  };
  /** @description Organization represents an organization */
  Organization: {
    avatar_url?: string;
    description?: string;
    email?: string;
    full_name?: string;
    /** Format: int64 */
    id?: number;
    location?: string;
    name?: string;
    repo_admin_change_team_access?: boolean;
    /** @description deprecated */
    username?: string;
    visibility?: string;
    website?: string;
  };
  /** @description OrganizationPermissions list different users permissions on an organization */
  OrganizationPermissions: {
    can_create_repository?: boolean;
    can_read?: boolean;
    can_write?: boolean;
    is_admin?: boolean;
    is_owner?: boolean;
  };
  /** @description PRBranchInfo information about a branch */
  PRBranchInfo: {
    label?: string;
    ref?: string;
    repo?: definitions["Repository"];
    /** Format: int64 */
    repo_id?: number;
    sha?: string;
  };
  /** @description Package represents a package */
  Package: {
    /** Format: date-time */
    created_at?: string;
    creator?: definitions["User"];
    html_url?: string;
    /** Format: int64 */
    id?: number;
    name?: string;
    owner?: definitions["User"];
    repository?: definitions["Repository"];
    type?: string;
    version?: string;
  };
  /** @description PackageFile represents a package file */
  PackageFile: {
    /** Format: int64 */
    Size?: number;
    /** Format: int64 */
    id?: number;
    md5?: string;
    name?: string;
    sha1?: string;
    sha256?: string;
    sha512?: string;
  };
  /** @description PayloadCommit represents a commit */
  PayloadCommit: {
    added?: string[];
    author?: definitions["PayloadUser"];
    committer?: definitions["PayloadUser"];
    /** @description sha1 hash of the commit */
    id?: string;
    message?: string;
    modified?: string[];
    removed?: string[];
    /** Format: date-time */
    timestamp?: string;
    url?: string;
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description PayloadCommitVerification represents the GPG verification of a commit */
  PayloadCommitVerification: {
    payload?: string;
    reason?: string;
    signature?: string;
    signer?: definitions["PayloadUser"];
    verified?: boolean;
  };
  /** @description PayloadUser represents the author or committer of a commit */
  PayloadUser: {
    /** Format: email */
    email?: string;
    /** @description Full name of the commit author */
    name?: string;
    username?: string;
  };
  /** @description Permission represents a set of permissions */
  Permission: {
    admin?: boolean;
    pull?: boolean;
    push?: boolean;
  };
  /** @description PublicKey publickey is a user key to push code to repository */
  PublicKey: {
    /** Format: date-time */
    created_at?: string;
    fingerprint?: string;
    /** Format: int64 */
    id?: number;
    key?: string;
    key_type?: string;
    read_only?: boolean;
    title?: string;
    url?: string;
    user?: definitions["User"];
  };
  /** @description PullRequest represents a pull request */
  PullRequest: {
    allow_maintainer_edit?: boolean;
    assignee?: definitions["User"];
    assignees?: definitions["User"][];
    base?: definitions["PRBranchInfo"];
    body?: string;
    /** Format: date-time */
    closed_at?: string;
    /** Format: int64 */
    comments?: number;
    /** Format: date-time */
    created_at?: string;
    diff_url?: string;
    /** Format: date-time */
    due_date?: string;
    head?: definitions["PRBranchInfo"];
    html_url?: string;
    /** Format: int64 */
    id?: number;
    is_locked?: boolean;
    labels?: definitions["Label"][];
    merge_base?: string;
    merge_commit_sha?: string;
    mergeable?: boolean;
    merged?: boolean;
    /** Format: date-time */
    merged_at?: string;
    merged_by?: definitions["User"];
    milestone?: definitions["Milestone"];
    /** Format: int64 */
    number?: number;
    patch_url?: string;
    /** Format: int64 */
    pin_order?: number;
    requested_reviewers?: definitions["User"][];
    state?: definitions["StateType"];
    title?: string;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
    user?: definitions["User"];
  };
  /** @description PullRequestMeta PR info if an issue is a PR */
  PullRequestMeta: {
    draft?: boolean;
    merged?: boolean;
    /** Format: date-time */
    merged_at?: string;
  };
  /** @description PullReview represents a pull request review */
  PullReview: {
    body?: string;
    /** Format: int64 */
    comments_count?: number;
    commit_id?: string;
    dismissed?: boolean;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    official?: boolean;
    pull_request_url?: string;
    stale?: boolean;
    state?: definitions["ReviewStateType"];
    /** Format: date-time */
    submitted_at?: string;
    team?: definitions["Team"];
    /** Format: date-time */
    updated_at?: string;
    user?: definitions["User"];
  };
  /** @description PullReviewComment represents a comment on a pull request review */
  PullReviewComment: {
    body?: string;
    commit_id?: string;
    /** Format: date-time */
    created_at?: string;
    diff_hunk?: string;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    original_commit_id?: string;
    /** Format: uint64 */
    original_position?: number;
    path?: string;
    /** Format: uint64 */
    position?: number;
    /** Format: int64 */
    pull_request_review_id?: number;
    pull_request_url?: string;
    resolver?: definitions["User"];
    /** Format: date-time */
    updated_at?: string;
    user?: definitions["User"];
  };
  /** @description PullReviewRequestOptions are options to add or remove pull review requests */
  PullReviewRequestOptions: {
    reviewers?: string[];
    team_reviewers?: string[];
  };
  /** @description PushMirror represents information of a push mirror */
  PushMirror: {
    /** Format: date-time */
    created?: string;
    interval?: string;
    last_error?: string;
    /** Format: date-time */
    last_update?: string;
    remote_address?: string;
    remote_name?: string;
    repo_name?: string;
    sync_on_commit?: boolean;
  };
  /** @description Reaction contain one reaction */
  Reaction: {
    content?: string;
    /** Format: date-time */
    created_at?: string;
    user?: definitions["User"];
  };
  /** Reference represents a Git reference. */
  Reference: {
    object?: definitions["GitObject"];
    ref?: string;
    url?: string;
  };
  /** @description Release represents a repository release */
  Release: {
    assets?: definitions["Attachment"][];
    author?: definitions["User"];
    body?: string;
    /** Format: date-time */
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    name?: string;
    prerelease?: boolean;
    /** Format: date-time */
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;
  };
  /** @description RenameUserOption options when renaming a user */
  RenameUserOption: {
    /** @description New username for this user. This name cannot be in use yet by any other user. */
    new_username: string;
  };
  /** @description RepoCollaboratorPermission to get repository permission for a collaborator */
  RepoCollaboratorPermission: {
    permission?: string;
    role_name?: string;
    user?: definitions["User"];
  };
  /** RepoCommit contains information of a commit in the context of a repository. */
  RepoCommit: {
    author?: definitions["CommitUser"];
    committer?: definitions["CommitUser"];
    message?: string;
    tree?: definitions["CommitMeta"];
    url?: string;
    verification?: definitions["PayloadCommitVerification"];
  };
  /** @description RepoTopicOptions a collection of repo topic names */
  RepoTopicOptions: {
    /** @description list of topic names */
    topics?: string[];
  };
  /** @description RepoTransfer represents a pending repo transfer */
  RepoTransfer: {
    doer?: definitions["User"];
    recipient?: definitions["User"];
    teams?: definitions["Team"][];
  };
  /** @description Repository represents a repository */
  Repository: {
    allow_fast_forward_only_merge?: boolean;
    allow_merge_commits?: boolean;
    allow_rebase?: boolean;
    allow_rebase_explicit?: boolean;
    allow_rebase_update?: boolean;
    allow_squash_merge?: boolean;
    archived?: boolean;
    /** Format: date-time */
    archived_at?: string;
    avatar_url?: string;
    clone_url?: string;
    /** Format: date-time */
    created_at?: string;
    default_allow_maintainer_edit?: boolean;
    default_branch?: string;
    default_delete_branch_after_merge?: boolean;
    default_merge_style?: string;
    description?: string;
    empty?: boolean;
    external_tracker?: definitions["ExternalTracker"];
    external_wiki?: definitions["ExternalWiki"];
    fork?: boolean;
    /** Format: int64 */
    forks_count?: number;
    full_name?: string;
    has_actions?: boolean;
    has_issues?: boolean;
    has_packages?: boolean;
    has_projects?: boolean;
    has_pull_requests?: boolean;
    has_releases?: boolean;
    has_wiki?: boolean;
    html_url?: string;
    /** Format: int64 */
    id?: number;
    ignore_whitespace_conflicts?: boolean;
    internal?: boolean;
    internal_tracker?: definitions["InternalTracker"];
    language?: string;
    languages_url?: string;
    link?: string;
    mirror?: boolean;
    mirror_interval?: string;
    /** Format: date-time */
    mirror_updated?: string;
    name?: string;
    /**
     * @description ObjectFormatName of the underlying git repository
     * @enum {string}
     */
    object_format_name?: "sha1" | "sha256";
    /** Format: int64 */
    open_issues_count?: number;
    /** Format: int64 */
    open_pr_counter?: number;
    original_url?: string;
    owner?: definitions["User"];
    parent?: definitions["Repository"];
    permissions?: definitions["Permission"];
    private?: boolean;
    projects_mode?: string;
    /** Format: int64 */
    release_counter?: number;
    repo_transfer?: definitions["RepoTransfer"];
    /** Format: int64 */
    size?: number;
    ssh_url?: string;
    /** Format: int64 */
    stars_count?: number;
    template?: boolean;
    /** Format: date-time */
    updated_at?: string;
    url?: string;
    /** Format: int64 */
    watchers_count?: number;
    website?: string;
  };
  /** @description RepositoryMeta basic repository information */
  RepositoryMeta: {
    full_name?: string;
    /** Format: int64 */
    id?: number;
    name?: string;
    owner?: string;
  };
  /** @description ReviewStateType review state type */
  ReviewStateType: string;
  /** @description SearchResults results of a successful search */
  SearchResults: {
    data?: definitions["Repository"][];
    ok?: boolean;
  };
  /** @description Secret represents a secret */
  Secret: {
    /** Format: date-time */
    created_at?: string;
    /** @description the secret's name */
    name?: string;
  };
  /** @description ServerVersion wraps the version of the server */
  ServerVersion: {
    version?: string;
  };
  /** @description StateType issue state type */
  StateType: string;
  /** @description StopWatch represent a running stopwatch */
  StopWatch: {
    /** Format: date-time */
    created?: string;
    duration?: string;
    /** Format: int64 */
    issue_index?: number;
    issue_title?: string;
    repo_name?: string;
    repo_owner_name?: string;
    /** Format: int64 */
    seconds?: number;
  };
  /** @description SubmitPullReviewOptions are options to submit a pending pull review */
  SubmitPullReviewOptions: {
    body?: string;
    event?: definitions["ReviewStateType"];
  };
  /** @description Tag represents a repository tag */
  Tag: {
    commit?: definitions["CommitMeta"];
    id?: string;
    message?: string;
    name?: string;
    tarball_url?: string;
    zipball_url?: string;
  };
  /** @description Team represents a team in an organization */
  Team: {
    can_create_org_repo?: boolean;
    description?: string;
    /** Format: int64 */
    id?: number;
    includes_all_repositories?: boolean;
    name?: string;
    organization?: definitions["Organization"];
    /** @enum {string} */
    permission?: "none" | "read" | "write" | "admin" | "owner";
    /**
     * @example [
     *   "repo.code",
     *   "repo.issues",
     *   "repo.ext_issues",
     *   "repo.wiki",
     *   "repo.pulls",
     *   "repo.releases",
     *   "repo.projects",
     *   "repo.ext_wiki"
     * ]
     */
    units?: string[];
    /**
     * @example {
     *   "repo.code": "read",
     *   "repo.ext_issues": "none",
     *   "repo.ext_wiki": "none",
     *   "repo.issues": "write",
     *   "repo.projects": "none",
     *   "repo.pulls": "owner",
     *   "repo.releases": "none",
     *   "repo.wiki": "admin"
     * }
     */
    units_map?: { [key: string]: string };
  };
  /**
   * Format: int64
   * @description TimeStamp defines a timestamp
   */
  TimeStamp: number;
  /** @description TimelineComment represents a timeline comment (comment of any type) on a commit or issue */
  TimelineComment: {
    assignee?: definitions["User"];
    assignee_team?: definitions["Team"];
    body?: string;
    /** Format: date-time */
    created_at?: string;
    dependent_issue?: definitions["Issue"];
    html_url?: string;
    /** Format: int64 */
    id?: number;
    issue_url?: string;
    label?: definitions["Label"];
    milestone?: definitions["Milestone"];
    new_ref?: string;
    new_title?: string;
    old_milestone?: definitions["Milestone"];
    /** Format: int64 */
    old_project_id?: number;
    old_ref?: string;
    old_title?: string;
    /** Format: int64 */
    project_id?: number;
    pull_request_url?: string;
    ref_action?: string;
    ref_comment?: definitions["Comment"];
    /** @description commit SHA where issue/PR was referenced */
    ref_commit_sha?: string;
    ref_issue?: definitions["Issue"];
    /** @description whether the assignees were removed or added */
    removed_assignee?: boolean;
    resolve_doer?: definitions["User"];
    /** Format: int64 */
    review_id?: number;
    tracked_time?: definitions["TrackedTime"];
    type?: string;
    /** Format: date-time */
    updated_at?: string;
    user?: definitions["User"];
  };
  /** @description TopicName a list of repo topic names */
  TopicName: {
    topics?: string[];
  };
  /** @description TopicResponse for returning topics */
  TopicResponse: {
    /** Format: date-time */
    created?: string;
    /** Format: int64 */
    id?: number;
    /** Format: int64 */
    repo_count?: number;
    topic_name?: string;
    /** Format: date-time */
    updated?: string;
  };
  /** @description TrackedTime worked time for an issue / pr */
  TrackedTime: {
    /** Format: date-time */
    created?: string;
    /** Format: int64 */
    id?: number;
    issue?: definitions["Issue"];
    /**
     * Format: int64
     * @description deprecated (only for backwards compatibility)
     */
    issue_id?: number;
    /**
     * Format: int64
     * @description Time in seconds
     */
    time?: number;
    /**
     * Format: int64
     * @description deprecated (only for backwards compatibility)
     */
    user_id?: number;
    user_name?: string;
  };
  /** @description TransferRepoOption options when transfer a repository's ownership */
  TransferRepoOption: {
    new_owner: string;
    /** @description ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories. */
    team_ids?: number[];
  };
  /**
   * @description UpdateFileOptions options for updating files
   * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
   */
  UpdateFileOptions: {
    author?: definitions["Identity"];
    /** @description branch (optional) to base this file from. if not given, the default branch is used */
    branch?: string;
    committer?: definitions["Identity"];
    /** @description content must be base64 encoded */
    content: string;
    dates?: definitions["CommitDateOptions"];
    /** @description from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL */
    from_path?: string;
    /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
    message?: string;
    /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
    new_branch?: string;
    /** @description sha is the SHA for the file that already exists */
    sha: string;
    /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
    signoff?: boolean;
  };
  /** @description UpdateRepoAvatarUserOption options when updating the repo avatar */
  UpdateRepoAvatarOption: {
    /** @description image must be base64 encoded */
    image?: string;
  };
  /** @description UpdateUserAvatarUserOption options when updating the user avatar */
  UpdateUserAvatarOption: {
    /** @description image must be base64 encoded */
    image?: string;
  };
  /** @description UpdateVariableOption the option when updating variable */
  UpdateVariableOption: {
    /** @description New name for the variable. If the field is empty, the variable name won't be updated. */
    name?: string;
    /** @description Value of the variable to update */
    value: string;
  };
  /** @description User represents a user */
  User: {
    /** @description Is user active */
    active?: boolean;
    /** @description URL to the user's avatar */
    avatar_url?: string;
    /** Format: date-time */
    created?: string;
    /** @description the user's description */
    description?: string;
    /** Format: email */
    email?: string;
    /**
     * Format: int64
     * @description user counts
     */
    followers_count?: number;
    /** Format: int64 */
    following_count?: number;
    /** @description the user's full name */
    full_name?: string;
    /**
     * Format: int64
     * @description the user's id
     */
    id?: number;
    /** @description Is the user an administrator */
    is_admin?: boolean;
    /** @description User locale */
    language?: string;
    /** Format: date-time */
    last_login?: string;
    /** @description the user's location */
    location?: string;
    /** @description the user's username */
    login?: string;
    /**
     * @description the user's authentication sign-in name.
     * @default empty
     */
    login_name?: string;
    /** @description Is user login prohibited */
    prohibit_login?: boolean;
    /** @description Is user restricted */
    restricted?: boolean;
    /**
     * Format: int64
     * @description The ID of the user's Authentication Source
     */
    source_id?: number;
    /** Format: int64 */
    starred_repos_count?: number;
    /** @description User visibility level option: public, limited, private */
    visibility?: string;
    /** @description the user's website */
    website?: string;
  };
  /** @description UserBadgeOption options for link between users and badges */
  UserBadgeOption: {
    /**
     * @example [
     *   "badge1",
     *   "badge2"
     * ]
     */
    badge_slugs?: string[];
  };
  /** @description UserHeatmapData represents the data needed to create a heatmap */
  UserHeatmapData: {
    /** Format: int64 */
    contributions?: number;
    timestamp?: definitions["TimeStamp"];
  };
  /** @description UserSettings represents user settings */
  UserSettings: {
    description?: string;
    diff_view_style?: string;
    full_name?: string;
    hide_activity?: boolean;
    /** @description Privacy */
    hide_email?: boolean;
    language?: string;
    location?: string;
    theme?: string;
    website?: string;
  };
  /** @description UserSettingsOptions represents options to change user settings */
  UserSettingsOptions: {
    description?: string;
    diff_view_style?: string;
    full_name?: string;
    hide_activity?: boolean;
    /** @description Privacy */
    hide_email?: boolean;
    language?: string;
    location?: string;
    theme?: string;
    website?: string;
  };
  /** @description WatchInfo represents an API watch status of one repository */
  WatchInfo: {
    /** Format: date-time */
    created_at?: string;
    ignored?: boolean;
    reason?: unknown;
    repository_url?: string;
    subscribed?: boolean;
    url?: string;
  };
  /** @description WikiCommit page commit/revision */
  WikiCommit: {
    author?: definitions["CommitUser"];
    commiter?: definitions["CommitUser"];
    message?: string;
    sha?: string;
  };
  /** @description WikiCommitList commit/revision list */
  WikiCommitList: {
    commits?: definitions["WikiCommit"][];
    /** Format: int64 */
    count?: number;
  };
  /** @description WikiPage a wiki page */
  WikiPage: {
    /** Format: int64 */
    commit_count?: number;
    /** @description Page content, base64 encoded */
    content_base64?: string;
    footer?: string;
    html_url?: string;
    last_commit?: definitions["WikiCommit"];
    sidebar?: string;
    sub_url?: string;
    title?: string;
  };
  /** @description WikiPageMetaData wiki page meta information */
  WikiPageMetaData: {
    html_url?: string;
    last_commit?: definitions["WikiCommit"];
    sub_url?: string;
    title?: string;
  };
}

export interface responses {
  /** AccessToken represents an API access token. */
  AccessToken: {
    schema: definitions["AccessToken"];
  };
  /** AccessTokenList represents a list of API access token. */
  AccessTokenList: {
    schema: definitions["AccessToken"][];
  };
  /** ActionVariable */
  ActionVariable: {
    schema: definitions["ActionVariable"];
  };
  /** ActivityFeedsList */
  ActivityFeedsList: {
    schema: definitions["Activity"][];
  };
  /** ActivityPub */
  ActivityPub: {
    schema: definitions["ActivityPub"];
  };
  /** AnnotatedTag */
  AnnotatedTag: {
    schema: definitions["AnnotatedTag"];
  };
  /** Attachment */
  Attachment: {
    schema: definitions["Attachment"];
  };
  /** AttachmentList */
  AttachmentList: {
    schema: definitions["Attachment"][];
  };
  /** BadgeList */
  BadgeList: {
    schema: definitions["Badge"][];
  };
  /** Branch */
  Branch: {
    schema: definitions["Branch"];
  };
  /** BranchList */
  BranchList: {
    schema: definitions["Branch"][];
  };
  /** BranchProtection */
  BranchProtection: {
    schema: definitions["BranchProtection"];
  };
  /** BranchProtectionList */
  BranchProtectionList: {
    schema: definitions["BranchProtection"][];
  };
  /** ChangedFileList */
  ChangedFileList: {
    headers: {};
    schema: definitions["ChangedFile"][];
  };
  /** CombinedStatus */
  CombinedStatus: {
    schema: definitions["CombinedStatus"];
  };
  /** Comment */
  Comment: {
    schema: definitions["Comment"];
  };
  /** CommentList */
  CommentList: {
    schema: definitions["Comment"][];
  };
  /** Commit */
  Commit: {
    schema: definitions["Commit"];
  };
  /** CommitList */
  CommitList: {
    headers: {};
    schema: definitions["Commit"][];
  };
  /** CommitStatus */
  CommitStatus: {
    schema: definitions["CommitStatus"];
  };
  /** CommitStatusList */
  CommitStatusList: {
    schema: definitions["CommitStatus"][];
  };
  Compare: {
    schema: definitions["Compare"];
  };
  /** ContentsListResponse */
  ContentsListResponse: {
    schema: definitions["ContentsResponse"][];
  };
  /** ContentsResponse */
  ContentsResponse: {
    schema: definitions["ContentsResponse"];
  };
  /** CronList */
  CronList: {
    schema: definitions["Cron"][];
  };
  /** DeployKey */
  DeployKey: {
    schema: definitions["DeployKey"];
  };
  /** DeployKeyList */
  DeployKeyList: {
    schema: definitions["DeployKey"][];
  };
  /** EmailList */
  EmailList: {
    schema: definitions["Email"][];
  };
  /** EmptyRepository */
  EmptyRepository: {
    schema: definitions["APIError"];
  };
  /** FileDeleteResponse */
  FileDeleteResponse: {
    schema: definitions["FileDeleteResponse"];
  };
  /** FileResponse */
  FileResponse: {
    schema: definitions["FileResponse"];
  };
  /** FilesResponse */
  FilesResponse: {
    schema: definitions["FilesResponse"];
  };
  /** GPGKey */
  GPGKey: {
    schema: definitions["GPGKey"];
  };
  /** GPGKeyList */
  GPGKeyList: {
    schema: definitions["GPGKey"][];
  };
  /** GeneralAPISettings */
  GeneralAPISettings: {
    schema: definitions["GeneralAPISettings"];
  };
  /** GeneralAttachmentSettings */
  GeneralAttachmentSettings: {
    schema: definitions["GeneralAttachmentSettings"];
  };
  /** GeneralRepoSettings */
  GeneralRepoSettings: {
    schema: definitions["GeneralRepoSettings"];
  };
  /** GeneralUISettings */
  GeneralUISettings: {
    schema: definitions["GeneralUISettings"];
  };
  /** GitBlobResponse */
  GitBlobResponse: {
    schema: definitions["GitBlobResponse"];
  };
  /** GitHook */
  GitHook: {
    schema: definitions["GitHook"];
  };
  /** GitHookList */
  GitHookList: {
    schema: definitions["GitHook"][];
  };
  /** GitTreeResponse */
  GitTreeResponse: {
    schema: definitions["GitTreeResponse"];
  };
  /** GitignoreTemplateInfo */
  GitignoreTemplateInfo: {
    schema: definitions["GitignoreTemplateInfo"];
  };
  /** GitignoreTemplateList */
  GitignoreTemplateList: {
    schema: string[];
  };
  /** Hook */
  Hook: {
    schema: definitions["Hook"];
  };
  /** HookList */
  HookList: {
    schema: definitions["Hook"][];
  };
  /** Issue */
  Issue: {
    schema: definitions["Issue"];
  };
  /** IssueDeadline */
  IssueDeadline: {
    schema: definitions["IssueDeadline"];
  };
  /** IssueList */
  IssueList: {
    schema: definitions["Issue"][];
  };
  /** IssueTemplates */
  IssueTemplates: {
    schema: definitions["IssueTemplate"][];
  };
  /** Label */
  Label: {
    schema: definitions["Label"];
  };
  /** LabelList */
  LabelList: {
    schema: definitions["Label"][];
  };
  /** LabelTemplateInfo */
  LabelTemplateInfo: {
    schema: definitions["LabelTemplate"][];
  };
  /** LabelTemplateList */
  LabelTemplateList: {
    schema: string[];
  };
  /** LanguageStatistics */
  LanguageStatistics: {
    schema: { [key: string]: number };
  };
  /** LicenseTemplateInfo */
  LicenseTemplateInfo: {
    schema: definitions["LicenseTemplateInfo"];
  };
  /** LicenseTemplateList */
  LicenseTemplateList: {
    schema: definitions["LicensesTemplateListEntry"][];
  };
  /** MarkdownRender is a rendered markdown document */
  MarkdownRender: {
    schema: string;
  };
  /** MarkupRender is a rendered markup document */
  MarkupRender: {
    schema: string;
  };
  /** Milestone */
  Milestone: {
    schema: definitions["Milestone"];
  };
  /** MilestoneList */
  MilestoneList: {
    schema: definitions["Milestone"][];
  };
  /** NodeInfo */
  NodeInfo: {
    schema: definitions["NodeInfo"];
  };
  /** Note */
  Note: {
    schema: definitions["Note"];
  };
  /** Number of unread notifications */
  NotificationCount: {
    schema: definitions["NotificationCount"];
  };
  /** NotificationThread */
  NotificationThread: {
    schema: definitions["NotificationThread"];
  };
  /** NotificationThreadList */
  NotificationThreadList: {
    schema: definitions["NotificationThread"][];
  };
  /** OAuth2Application */
  OAuth2Application: {
    schema: definitions["OAuth2Application"];
  };
  /** OAuth2ApplicationList represents a list of OAuth2 applications. */
  OAuth2ApplicationList: {
    schema: definitions["OAuth2Application"][];
  };
  /** Organization */
  Organization: {
    schema: definitions["Organization"];
  };
  /** OrganizationList */
  OrganizationList: {
    schema: definitions["Organization"][];
  };
  /** OrganizationPermissions */
  OrganizationPermissions: {
    schema: definitions["OrganizationPermissions"];
  };
  /** Package */
  Package: {
    schema: definitions["Package"];
  };
  /** PackageFileList */
  PackageFileList: {
    schema: definitions["PackageFile"][];
  };
  /** PackageList */
  PackageList: {
    schema: definitions["Package"][];
  };
  /** PublicKey */
  PublicKey: {
    schema: definitions["PublicKey"];
  };
  /** PublicKeyList */
  PublicKeyList: {
    schema: definitions["PublicKey"][];
  };
  /** PullRequest */
  PullRequest: {
    schema: definitions["PullRequest"];
  };
  /** PullRequestList */
  PullRequestList: {
    schema: definitions["PullRequest"][];
  };
  /** PullReview */
  PullReview: {
    schema: definitions["PullReview"];
  };
  /** PullComment */
  PullReviewComment: {
    schema: definitions["PullReviewComment"];
  };
  /** PullCommentList */
  PullReviewCommentList: {
    schema: definitions["PullReviewComment"][];
  };
  /** PullReviewList */
  PullReviewList: {
    schema: definitions["PullReview"][];
  };
  /** PushMirror */
  PushMirror: {
    schema: definitions["PushMirror"];
  };
  /** PushMirrorList */
  PushMirrorList: {
    schema: definitions["PushMirror"][];
  };
  /** Reaction */
  Reaction: {
    schema: definitions["Reaction"];
  };
  /** ReactionList */
  ReactionList: {
    schema: definitions["Reaction"][];
  };
  /** Reference */
  Reference: {
    schema: definitions["Reference"];
  };
  /** ReferenceList */
  ReferenceList: {
    schema: definitions["Reference"][];
  };
  /** RegistrationToken is response related to registration token */
  RegistrationToken: unknown;
  /** Release */
  Release: {
    schema: definitions["Release"];
  };
  /** ReleaseList */
  ReleaseList: {
    schema: definitions["Release"][];
  };
  /** RepoCollaboratorPermission */
  RepoCollaboratorPermission: {
    schema: definitions["RepoCollaboratorPermission"];
  };
  /** RepoIssueConfig */
  RepoIssueConfig: {
    schema: definitions["IssueConfig"];
  };
  /** RepoIssueConfigValidation */
  RepoIssueConfigValidation: {
    schema: definitions["IssueConfigValidation"];
  };
  /** RepoNewIssuePinsAllowed */
  RepoNewIssuePinsAllowed: {
    schema: definitions["NewIssuePinsAllowed"];
  };
  /** Repository */
  Repository: {
    schema: definitions["Repository"];
  };
  /** RepositoryList */
  RepositoryList: {
    schema: definitions["Repository"][];
  };
  /** SearchResults */
  SearchResults: {
    schema: definitions["SearchResults"];
  };
  /** Secret */
  Secret: {
    schema: definitions["Secret"];
  };
  /** SecretList */
  SecretList: {
    schema: definitions["Secret"][];
  };
  /** ServerVersion */
  ServerVersion: {
    schema: definitions["ServerVersion"];
  };
  /** StopWatch */
  StopWatch: {
    schema: definitions["StopWatch"];
  };
  /** StopWatchList */
  StopWatchList: {
    schema: definitions["StopWatch"][];
  };
  /** StringSlice */
  StringSlice: {
    schema: string[];
  };
  /** Tag */
  Tag: {
    schema: definitions["Tag"];
  };
  /** TagList */
  TagList: {
    schema: definitions["Tag"][];
  };
  /** TasksList */
  TasksList: {
    schema: definitions["ActionTaskResponse"];
  };
  /** Team */
  Team: {
    schema: definitions["Team"];
  };
  /** TeamList */
  TeamList: {
    schema: definitions["Team"][];
  };
  /** TimelineList */
  TimelineList: {
    schema: definitions["TimelineComment"][];
  };
  /** TopicListResponse */
  TopicListResponse: {
    schema: definitions["TopicResponse"][];
  };
  /** TopicNames */
  TopicNames: {
    schema: definitions["TopicName"];
  };
  /** TrackedTime */
  TrackedTime: {
    schema: definitions["TrackedTime"];
  };
  /** TrackedTimeList */
  TrackedTimeList: {
    schema: definitions["TrackedTime"][];
  };
  /** User */
  User: {
    schema: definitions["User"];
  };
  /** UserHeatmapData */
  UserHeatmapData: {
    schema: definitions["UserHeatmapData"][];
  };
  /** UserList */
  UserList: {
    schema: definitions["User"][];
  };
  /** UserSettings */
  UserSettings: {
    schema: definitions["UserSettings"][];
  };
  /** VariableList */
  VariableList: {
    schema: definitions["ActionVariable"][];
  };
  /** WatchInfo */
  WatchInfo: {
    schema: definitions["WatchInfo"];
  };
  /** WikiCommitList */
  WikiCommitList: {
    schema: definitions["WikiCommitList"];
  };
  /** WikiPage */
  WikiPage: {
    schema: definitions["WikiPage"];
  };
  /** WikiPageList */
  WikiPageList: {
    schema: definitions["WikiPageMetaData"][];
  };
  /** APIConflict is a conflict empty response */
  conflict: unknown;
  /** APIEmpty is an empty response */
  empty: unknown;
  /** APIError is error format response */
  error: unknown;
  /** APIForbiddenError is a forbidden error response */
  forbidden: unknown;
  /** APIInvalidTopicsError is error format response to invalid topics */
  invalidTopicsError: unknown;
  /** APINotFound is a not found empty response */
  notFound: unknown;
  /** parameterBodies */
  parameterBodies: {
    schema: definitions["UpdateVariableOption"];
  };
  /** APIRedirect is a redirect response */
  redirect: unknown;
  /** APIRepoArchivedError is an error that is raised when an archived repo should be modified */
  repoArchivedError: unknown;
  /** APIString is a string response */
  string: {
    schema: string;
  };
  /** APIValidationError is error format response related to input validation */
  validationError: unknown;
}

export interface operations {
  activitypubPerson: {
    parameters: {
      path: {
        /** user ID of the user */
        "user-id": number;
      };
    };
    responses: {
      200: responses["ActivityPub"];
    };
  };
  activitypubPersonInbox: {
    parameters: {
      path: {
        /** user ID of the user */
        "user-id": number;
      };
    };
    responses: {
      204: responses["empty"];
    };
  };
  adminCronList: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["CronList"];
      403: responses["forbidden"];
    };
  };
  adminCronRun: {
    parameters: {
      path: {
        /** task to run */
        task: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  adminGetAllEmails: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["EmailList"];
      403: responses["forbidden"];
    };
  };
  adminSearchEmails: {
    parameters: {
      query: {
        /** keyword */
        q?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["EmailList"];
      403: responses["forbidden"];
    };
  };
  adminListHooks: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["HookList"];
    };
  };
  adminCreateHook: {
    parameters: {
      body: {
        body: definitions["CreateHookOption"];
      };
    };
    responses: {
      201: responses["Hook"];
    };
  };
  adminGetHook: {
    parameters: {
      path: {
        /** id of the hook to get */
        id: number;
      };
    };
    responses: {
      200: responses["Hook"];
    };
  };
  adminDeleteHook: {
    parameters: {
      path: {
        /** id of the hook to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
    };
  };
  adminEditHook: {
    parameters: {
      path: {
        /** id of the hook to update */
        id: number;
      };
      body: {
        body?: definitions["EditHookOption"];
      };
    };
    responses: {
      200: responses["Hook"];
    };
  };
  adminGetAllOrgs: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["OrganizationList"];
      403: responses["forbidden"];
    };
  };
  adminGetRunnerRegistrationToken: {
    responses: {
      200: responses["RegistrationToken"];
    };
  };
  adminUnadoptedList: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
        /** pattern of repositories to search for */
        pattern?: string;
      };
    };
    responses: {
      200: responses["StringSlice"];
      403: responses["forbidden"];
    };
  };
  adminAdoptRepository: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  adminDeleteUnadoptedRepository: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
    };
  };
  adminSearchUsers: {
    parameters: {
      query: {
        /** ID of the user's login source to search for */
        source_id?: number;
        /** user's login name to search for */
        login_name?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      403: responses["forbidden"];
    };
  };
  adminCreateUser: {
    parameters: {
      body: {
        body?: definitions["CreateUserOption"];
      };
    };
    responses: {
      201: responses["User"];
      400: responses["error"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminDeleteUser: {
    parameters: {
      path: {
        /** username of user to delete */
        username: string;
      };
      query: {
        /** purge the user from the system completely */
        purge?: boolean;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  adminEditUser: {
    parameters: {
      path: {
        /** username of user to edit */
        username: string;
      };
      body: {
        body?: definitions["EditUserOption"];
      };
    };
    responses: {
      200: responses["User"];
      400: responses["error"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminListUserBadges: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
    };
    responses: {
      200: responses["BadgeList"];
      404: responses["notFound"];
    };
  };
  adminAddUserBadges: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      body: {
        body?: definitions["UserBadgeOption"];
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
    };
  };
  adminDeleteUserBadges: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      body: {
        body?: definitions["UserBadgeOption"];
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminCreatePublicKey: {
    parameters: {
      path: {
        /** username of the user */
        username: string;
      };
      body: {
        key?: definitions["CreateKeyOption"];
      };
    };
    responses: {
      201: responses["PublicKey"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminDeleteUserPublicKey: {
    parameters: {
      path: {
        /** username of user */
        username: string;
        /** id of the key to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  adminCreateOrg: {
    parameters: {
      path: {
        /** username of the user that will own the created organization */
        username: string;
      };
      body: {
        organization: definitions["CreateOrgOption"];
      };
    };
    responses: {
      201: responses["Organization"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminRenameUser: {
    parameters: {
      path: {
        /** existing username of user */
        username: string;
      };
      body: {
        body: definitions["RenameUserOption"];
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  adminCreateRepo: {
    parameters: {
      path: {
        /** username of the user. This user will own the created repository */
        username: string;
      };
      body: {
        repository: definitions["CreateRepoOption"];
      };
    };
    responses: {
      201: responses["Repository"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
      409: responses["error"];
      422: responses["validationError"];
    };
  };
  listGitignoresTemplates: {
    responses: {
      200: responses["GitignoreTemplateList"];
    };
  };
  getGitignoreTemplateInfo: {
    parameters: {
      path: {
        /** name of the template */
        name: string;
      };
    };
    responses: {
      200: responses["GitignoreTemplateInfo"];
      404: responses["notFound"];
    };
  };
  listLabelTemplates: {
    responses: {
      200: responses["LabelTemplateList"];
    };
  };
  getLabelTemplateInfo: {
    parameters: {
      path: {
        /** name of the template */
        name: string;
      };
    };
    responses: {
      200: responses["LabelTemplateInfo"];
      404: responses["notFound"];
    };
  };
  listLicenseTemplates: {
    responses: {
      200: responses["LicenseTemplateList"];
    };
  };
  getLicenseTemplateInfo: {
    parameters: {
      path: {
        /** name of the license */
        name: string;
      };
    };
    responses: {
      200: responses["LicenseTemplateInfo"];
      404: responses["notFound"];
    };
  };
  renderMarkdown: {
    parameters: {
      body: {
        body?: definitions["MarkdownOption"];
      };
    };
    responses: {
      200: responses["MarkdownRender"];
      422: responses["validationError"];
    };
  };
  renderMarkdownRaw: {
    parameters: {
      body: {
        /** Request body to render */
        body: string;
      };
    };
    responses: {
      200: responses["MarkdownRender"];
      422: responses["validationError"];
    };
  };
  renderMarkup: {
    parameters: {
      body: {
        body?: definitions["MarkupOption"];
      };
    };
    responses: {
      200: responses["MarkupRender"];
      422: responses["validationError"];
    };
  };
  getNodeInfo: {
    responses: {
      200: responses["NodeInfo"];
    };
  };
  notifyGetList: {
    parameters: {
      query: {
        /** If true, show notifications marked as read. Default value is false */
        all?: boolean;
        /** Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned. */
        "status-types"?: string[];
        /** filter notifications by subject type */
        "subject-type"?: ("issue" | "pull" | "commit" | "repository")[];
        /** Only show notifications updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show notifications updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["NotificationThreadList"];
    };
  };
  notifyReadList: {
    parameters: {
      query: {
        /** Describes the last point that notifications were checked. Anything updated since this time will not be updated. */
        last_read_at?: string;
        /** If true, mark all notifications on this repo. Default value is false */
        all?: string;
        /** Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread. */
        "status-types"?: string[];
        /** Status to mark notifications as, Defaults to read. */
        "to-status"?: string;
      };
    };
    responses: {
      205: responses["NotificationThreadList"];
    };
  };
  notifyNewAvailable: {
    responses: {
      200: responses["NotificationCount"];
    };
  };
  notifyGetThread: {
    parameters: {
      path: {
        /** id of notification thread */
        id: string;
      };
    };
    responses: {
      200: responses["NotificationThread"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  notifyReadThread: {
    parameters: {
      path: {
        /** id of notification thread */
        id: string;
      };
      query: {
        /** Status to mark notifications as */
        "to-status"?: string;
      };
    };
    responses: {
      205: responses["NotificationThread"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  createOrgRepoDeprecated: {
    parameters: {
      path: {
        /** name of organization */
        org: string;
      };
      body: {
        body?: definitions["CreateRepoOption"];
      };
    };
    responses: {
      201: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  orgGetAll: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["OrganizationList"];
    };
  };
  orgCreate: {
    parameters: {
      body: {
        organization: definitions["CreateOrgOption"];
      };
    };
    responses: {
      201: responses["Organization"];
      403: responses["forbidden"];
      422: responses["validationError"];
    };
  };
  orgGet: {
    parameters: {
      path: {
        /** name of the organization to get */
        org: string;
      };
    };
    responses: {
      200: responses["Organization"];
      404: responses["notFound"];
    };
  };
  orgDelete: {
    parameters: {
      path: {
        /** organization that is to be deleted */
        org: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  orgEdit: {
    parameters: {
      path: {
        /** name of the organization to edit */
        org: string;
      };
      body: {
        body: definitions["EditOrgOption"];
      };
    };
    responses: {
      200: responses["Organization"];
      404: responses["notFound"];
    };
  };
  orgGetRunnerRegistrationToken: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
    };
    responses: {
      200: responses["RegistrationToken"];
    };
  };
  orgListActionsSecrets: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["SecretList"];
      404: responses["notFound"];
    };
  };
  updateOrgSecret: {
    parameters: {
      path: {
        /** name of organization */
        org: string;
        /** name of the secret */
        secretname: string;
      };
      body: {
        body?: definitions["CreateOrUpdateSecretOption"];
      };
    };
    responses: {
      /** response when creating a secret */
      201: unknown;
      /** response when updating a secret */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteOrgSecret: {
    parameters: {
      path: {
        /** name of organization */
        org: string;
        /** name of the secret */
        secretname: string;
      };
    };
    responses: {
      /** delete one secret of the organization */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  getOrgVariablesList: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["VariableList"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  getOrgVariable: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      200: responses["ActionVariable"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  updateOrgVariable: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["UpdateVariableOption"];
      };
    };
    responses: {
      /** response when updating an org-level variable */
      201: unknown;
      /** response when updating an org-level variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  createOrgVariable: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["CreateVariableOption"];
      };
    };
    responses: {
      /** response when creating an org-level variable */
      201: unknown;
      /** response when creating an org-level variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteOrgVariable: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      200: responses["ActionVariable"];
      /** response when deleting a variable */
      201: unknown;
      /** response when deleting a variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  orgListActivityFeeds: {
    parameters: {
      path: {
        /** name of the org */
        org: string;
      };
      query: {
        /** the date of the activities to be found */
        date?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ActivityFeedsList"];
      404: responses["notFound"];
    };
  };
  orgUpdateAvatar: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      body: {
        body?: definitions["UpdateUserAvatarOption"];
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  orgDeleteAvatar: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  organizationListBlocks: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
    };
  };
  organizationCheckUserBlock: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** user to check */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  organizationBlockUser: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** user to block */
        username: string;
      };
      query: {
        /** optional note for the block */
        note?: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  organizationUnblockUser: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** user to unblock */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  orgListHooks: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["HookList"];
      404: responses["notFound"];
    };
  };
  orgCreateHook: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      body: {
        body: definitions["CreateHookOption"];
      };
    };
    responses: {
      201: responses["Hook"];
      404: responses["notFound"];
    };
  };
  orgGetHook: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the hook to get */
        id: number;
      };
    };
    responses: {
      200: responses["Hook"];
      404: responses["notFound"];
    };
  };
  orgDeleteHook: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the hook to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  orgEditHook: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the hook to update */
        id: number;
      };
      body: {
        body?: definitions["EditHookOption"];
      };
    };
    responses: {
      200: responses["Hook"];
      404: responses["notFound"];
    };
  };
  orgListLabels: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["LabelList"];
      404: responses["notFound"];
    };
  };
  orgCreateLabel: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      body: {
        body?: definitions["CreateLabelOption"];
      };
    };
    responses: {
      201: responses["Label"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  orgGetLabel: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the label to get */
        id: number;
      };
    };
    responses: {
      200: responses["Label"];
      404: responses["notFound"];
    };
  };
  orgDeleteLabel: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the label to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  orgEditLabel: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** id of the label to edit */
        id: number;
      };
      body: {
        body?: definitions["EditLabelOption"];
      };
    };
    responses: {
      200: responses["Label"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  orgListMembers: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  orgIsMember: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** username of the user */
        username: string;
      };
    };
    responses: {
      /** user is a member */
      204: never;
      /** redirection to /orgs/{org}/public_members/{username} */
      303: never;
      /** user is not a member */
      404: unknown;
    };
  };
  orgDeleteMember: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** username of the user */
        username: string;
      };
    };
    responses: {
      /** member removed */
      204: never;
      404: responses["notFound"];
    };
  };
  orgListPublicMembers: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  orgIsPublicMember: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** username of the user */
        username: string;
      };
    };
    responses: {
      /** user is a public member */
      204: never;
      /** user is not a public member */
      404: unknown;
    };
  };
  orgPublicizeMember: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** username of the user */
        username: string;
      };
    };
    responses: {
      /** membership publicized */
      204: never;
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  orgConcealMember: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
        /** username of the user */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  orgListRepos: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  createOrgRepo: {
    parameters: {
      path: {
        /** name of organization */
        org: string;
      };
      body: {
        body?: definitions["CreateRepoOption"];
      };
    };
    responses: {
      201: responses["Repository"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  orgListTeams: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TeamList"];
      404: responses["notFound"];
    };
  };
  orgCreateTeam: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      body: {
        body?: definitions["CreateTeamOption"];
      };
    };
    responses: {
      201: responses["Team"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  teamSearch: {
    parameters: {
      path: {
        /** name of the organization */
        org: string;
      };
      query: {
        /** keywords to search */
        q?: string;
        /** include search within team description (defaults to true) */
        include_desc?: boolean;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      /** SearchResults of a successful search */
      200: {
        schema: {
          data?: definitions["Team"][];
          ok?: boolean;
        };
      };
      404: responses["notFound"];
    };
  };
  listPackages: {
    parameters: {
      path: {
        /** owner of the packages */
        owner: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
        /** package type filter */
        type?:
          | "alpine"
          | "cargo"
          | "chef"
          | "composer"
          | "conan"
          | "conda"
          | "container"
          | "cran"
          | "debian"
          | "generic"
          | "go"
          | "helm"
          | "maven"
          | "npm"
          | "nuget"
          | "pub"
          | "pypi"
          | "rpm"
          | "rubygems"
          | "swift"
          | "vagrant";
        /** name filter */
        q?: string;
      };
    };
    responses: {
      200: responses["PackageList"];
      404: responses["notFound"];
    };
  };
  getPackage: {
    parameters: {
      path: {
        /** owner of the package */
        owner: string;
        /** type of the package */
        type: string;
        /** name of the package */
        name: string;
        /** version of the package */
        version: string;
      };
    };
    responses: {
      200: responses["Package"];
      404: responses["notFound"];
    };
  };
  deletePackage: {
    parameters: {
      path: {
        /** owner of the package */
        owner: string;
        /** type of the package */
        type: string;
        /** name of the package */
        name: string;
        /** version of the package */
        version: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  listPackageFiles: {
    parameters: {
      path: {
        /** owner of the package */
        owner: string;
        /** type of the package */
        type: string;
        /** name of the package */
        name: string;
        /** version of the package */
        version: string;
      };
    };
    responses: {
      200: responses["PackageFileList"];
      404: responses["notFound"];
    };
  };
  issueSearchIssues: {
    parameters: {
      query: {
        /** whether issue is open or closed */
        state?: string;
        /** comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded */
        labels?: string;
        /** comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded */
        milestones?: string;
        /** search string */
        q?: string;
        /** repository to prioritize in the results */
        priority_repo_id?: number;
        /** filter by type (issues / pulls) if set */
        type?: string;
        /** Only show notifications updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show notifications updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** filter (issues / pulls) assigned to you, default is false */
        assigned?: boolean;
        /** filter (issues / pulls) created by you, default is false */
        created?: boolean;
        /** filter (issues / pulls) mentioning you, default is false */
        mentioned?: boolean;
        /** filter pulls requesting your review, default is false */
        review_requested?: boolean;
        /** filter pulls reviewed by you, default is false */
        reviewed?: boolean;
        /** filter by owner */
        owner?: string;
        /** filter by team (requires organization owner parameter to be provided) */
        team?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["IssueList"];
    };
  };
  repoMigrate: {
    parameters: {
      body: {
        body?: definitions["MigrateRepoOptions"];
      };
    };
    responses: {
      201: responses["Repository"];
      403: responses["forbidden"];
      /** The repository with the same name already exists. */
      409: unknown;
      422: responses["validationError"];
    };
  };
  repoSearch: {
    parameters: {
      query: {
        /** keyword */
        q?: string;
        /** Limit search to repositories with keyword as topic */
        topic?: boolean;
        /** include search of keyword within repository description */
        includeDesc?: boolean;
        /** search only for repos that the user with the given id owns or contributes to */
        uid?: number;
        /** repo owner to prioritize in the results */
        priority_owner_id?: number;
        /** search only for repos that belong to the given team id */
        team_id?: number;
        /** search only for repos that the user with the given id has starred */
        starredBy?: number;
        /** include private repositories this user has access to (defaults to true) */
        private?: boolean;
        /** show only pubic, private or all repositories (defaults to all) */
        is_private?: boolean;
        /** include template repositories this user has access to (defaults to true) */
        template?: boolean;
        /** show only archived, non-archived or all repositories (defaults to all) */
        archived?: boolean;
        /** type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative" */
        mode?: string;
        /** if `uid` is given, search only for repos that the user owns */
        exclusive?: boolean;
        /** sort repos by attribute. Supported values are "alpha", "created", "updated", "size", and "id". Default is "alpha" */
        sort?: string;
        /** sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified. */
        order?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["SearchResults"];
      422: responses["validationError"];
    };
  };
  repoGet: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["Repository"];
      404: responses["notFound"];
    };
  };
  repoDelete: {
    parameters: {
      path: {
        /** owner of the repo to delete */
        owner: string;
        /** name of the repo to delete */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoEdit: {
    parameters: {
      path: {
        /** owner of the repo to edit */
        owner: string;
        /** name of the repo to edit */
        repo: string;
      };
      body: {
        /** Properties of a repo that you can edit */
        body?: definitions["EditRepoOption"];
      };
    };
    responses: {
      200: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoListActionsSecrets: {
    parameters: {
      path: {
        /** owner of the repository */
        owner: string;
        /** name of the repository */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["SecretList"];
      404: responses["notFound"];
    };
  };
  updateRepoSecret: {
    parameters: {
      path: {
        /** owner of the repository */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the secret */
        secretname: string;
      };
      body: {
        body?: definitions["CreateOrUpdateSecretOption"];
      };
    };
    responses: {
      /** response when creating a secret */
      201: unknown;
      /** response when updating a secret */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteRepoSecret: {
    parameters: {
      path: {
        /** owner of the repository */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the secret */
        secretname: string;
      };
    };
    responses: {
      /** delete one secret of the organization */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  ListActionTasks: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results, default maximum page size is 50 */
        limit?: number;
      };
    };
    responses: {
      200: responses["TasksList"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
      409: responses["conflict"];
      422: responses["validationError"];
    };
  };
  getRepoVariablesList: {
    parameters: {
      path: {
        /** name of the owner */
        owner: string;
        /** name of the repository */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["VariableList"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  getRepoVariable: {
    parameters: {
      path: {
        /** name of the owner */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      200: responses["ActionVariable"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  updateRepoVariable: {
    parameters: {
      path: {
        /** name of the owner */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["UpdateVariableOption"];
      };
    };
    responses: {
      /** response when updating a repo-level variable */
      201: unknown;
      /** response when updating a repo-level variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  createRepoVariable: {
    parameters: {
      path: {
        /** name of the owner */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["CreateVariableOption"];
      };
    };
    responses: {
      /** response when creating a repo-level variable */
      201: unknown;
      /** response when creating a repo-level variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteRepoVariable: {
    parameters: {
      path: {
        /** name of the owner */
        owner: string;
        /** name of the repository */
        repo: string;
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      200: responses["ActionVariable"];
      /** response when deleting a variable */
      201: unknown;
      /** response when deleting a variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoListActivityFeeds: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** the date of the activities to be found */
        date?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ActivityFeedsList"];
      404: responses["notFound"];
    };
  };
  repoGetArchive: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** the git reference for download with attached archive format (e.g. master.zip) */
        archive: string;
      };
    };
    responses: {
      /** success */
      200: unknown;
      404: responses["notFound"];
    };
  };
  repoGetAssignees: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  repoUpdateAvatar: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["UpdateRepoAvatarOption"];
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoDeleteAvatar: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoListBranchProtection: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["BranchProtectionList"];
    };
  };
  repoCreateBranchProtection: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateBranchProtectionOption"];
      };
    };
    responses: {
      201: responses["BranchProtection"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetBranchProtection: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of protected branch */
        name: string;
      };
    };
    responses: {
      200: responses["BranchProtection"];
      404: responses["notFound"];
    };
  };
  repoDeleteBranchProtection: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of protected branch */
        name: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoEditBranchProtection: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of protected branch */
        name: string;
      };
      body: {
        body?: definitions["EditBranchProtectionOption"];
      };
    };
    responses: {
      200: responses["BranchProtection"];
      404: responses["notFound"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  repoListBranches: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["BranchList"];
    };
  };
  repoCreateBranch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateBranchRepoOption"];
      };
    };
    responses: {
      201: responses["Branch"];
      /** The branch is archived or a mirror. */
      403: unknown;
      /** The old branch does not exist. */
      404: unknown;
      /** The branch with the same name already exists. */
      409: unknown;
      423: responses["repoArchivedError"];
    };
  };
  repoGetBranch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** branch to get */
        branch: string;
      };
    };
    responses: {
      200: responses["Branch"];
      404: responses["notFound"];
    };
  };
  repoDeleteBranch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** branch to delete */
        branch: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["error"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoListCollaborators: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  repoCheckCollaborator: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** username of the collaborator */
        collaborator: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoAddCollaborator: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** username of the collaborator to add */
        collaborator: string;
      };
      body: {
        body?: definitions["AddCollaboratorOption"];
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoDeleteCollaborator: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** username of the collaborator to delete */
        collaborator: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoGetRepoPermissions: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** username of the collaborator */
        collaborator: string;
      };
    };
    responses: {
      200: responses["RepoCollaboratorPermission"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoGetAllCommits: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** SHA or branch to start listing commits from (usually 'master') */
        sha?: string;
        /** filepath of a file/dir */
        path?: string;
        /** include diff stats for every commit (disable for speedup, default 'true') */
        stat?: boolean;
        /** include verification for every commit (disable for speedup, default 'true') */
        verification?: boolean;
        /** include a list of affected files for every commit (disable for speedup, default 'true') */
        files?: boolean;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results (ignored if used with 'path') */
        limit?: number;
        /** commits that match the given specifier will not be listed. */
        not?: string;
      };
    };
    responses: {
      200: responses["CommitList"];
      404: responses["notFound"];
      409: responses["EmptyRepository"];
    };
  };
  repoGetCombinedStatusByRef: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of branch/tag/commit */
        ref: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["CombinedStatus"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoListStatusesByRef: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of branch/tag/commit */
        ref: string;
      };
      query: {
        /** type of sort */
        sort?:
          | "oldest"
          | "recentupdate"
          | "leastupdate"
          | "leastindex"
          | "highestindex";
        /** type of state */
        state?: "pending" | "success" | "error" | "failure" | "warning";
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["CommitStatusList"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoGetCommitPullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** SHA of the commit to get */
        sha: string;
      };
    };
    responses: {
      200: responses["PullRequest"];
      404: responses["notFound"];
    };
  };
  repoCompareDiff: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** compare two branches or commits */
        basehead: string;
      };
    };
    responses: {
      200: responses["Compare"];
      404: responses["notFound"];
    };
  };
  repoGetContentsList: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** The name of the commit/branch/tag. Default the repository’s default branch (usually master) */
        ref?: string;
      };
    };
    responses: {
      200: responses["ContentsListResponse"];
      404: responses["notFound"];
    };
  };
  repoChangeFiles: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body: definitions["ChangeFilesOptions"];
      };
    };
    responses: {
      201: responses["FilesResponse"];
      403: responses["error"];
      404: responses["notFound"];
      422: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetContents: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** path of the dir, file, symlink or submodule in the repo */
        filepath: string;
      };
      query: {
        /** The name of the commit/branch/tag. Default the repository’s default branch (usually master) */
        ref?: string;
      };
    };
    responses: {
      200: responses["ContentsResponse"];
      404: responses["notFound"];
    };
  };
  repoUpdateFile: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** path of the file to update */
        filepath: string;
      };
      body: {
        body: definitions["UpdateFileOptions"];
      };
    };
    responses: {
      200: responses["FileResponse"];
      403: responses["error"];
      404: responses["notFound"];
      422: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  repoCreateFile: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** path of the file to create */
        filepath: string;
      };
      body: {
        body: definitions["CreateFileOptions"];
      };
    };
    responses: {
      201: responses["FileResponse"];
      403: responses["error"];
      404: responses["notFound"];
      422: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  repoDeleteFile: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** path of the file to delete */
        filepath: string;
      };
      body: {
        body: definitions["DeleteFileOptions"];
      };
    };
    responses: {
      200: responses["FileDeleteResponse"];
      400: responses["error"];
      403: responses["error"];
      404: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  repoApplyDiffPatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body: definitions["UpdateFileOptions"];
      };
    };
    responses: {
      200: responses["FileResponse"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetEditorConfig: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** filepath of file to get */
        filepath: string;
      };
      query: {
        /** The name of the commit/branch/tag. Default the repository’s default branch (usually master) */
        ref?: string;
      };
    };
    responses: {
      /** success */
      200: unknown;
      404: responses["notFound"];
    };
  };
  listForks: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  createFork: {
    parameters: {
      path: {
        /** owner of the repo to fork */
        owner: string;
        /** name of the repo to fork */
        repo: string;
      };
      body: {
        body?: definitions["CreateForkOption"];
      };
    };
    responses: {
      202: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
      /** The repository with the same name already exists. */
      409: unknown;
      422: responses["validationError"];
    };
  };
  GetBlob: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** sha of the commit */
        sha: string;
      };
    };
    responses: {
      200: responses["GitBlobResponse"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoGetSingleCommit: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** a git ref or commit sha */
        sha: string;
      };
      query: {
        /** include diff stats for every commit (disable for speedup, default 'true') */
        stat?: boolean;
        /** include verification for every commit (disable for speedup, default 'true') */
        verification?: boolean;
        /** include a list of affected files for every commit (disable for speedup, default 'true') */
        files?: boolean;
      };
    };
    responses: {
      200: responses["Commit"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoDownloadCommitDiffOrPatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** SHA of the commit to get */
        sha: string;
        /** whether the output is diff or patch */
        diffType: "diff" | "patch";
      };
    };
    responses: {
      200: responses["string"];
      404: responses["notFound"];
    };
  };
  repoGetNote: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** a git ref or commit sha */
        sha: string;
      };
      query: {
        /** include verification for every commit (disable for speedup, default 'true') */
        verification?: boolean;
        /** include a list of affected files for every commit (disable for speedup, default 'true') */
        files?: boolean;
      };
    };
    responses: {
      200: responses["Note"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoListAllGitRefs: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["ReferenceList"];
      404: responses["notFound"];
    };
  };
  repoListGitRefs: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** part or full name of the ref */
        ref: string;
      };
    };
    responses: {
      200: responses["ReferenceList"];
      404: responses["notFound"];
    };
  };
  GetAnnotatedTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. */
        sha: string;
      };
    };
    responses: {
      200: responses["AnnotatedTag"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  GetTree: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** sha of the commit */
        sha: string;
      };
      query: {
        /** show all directories and files */
        recursive?: boolean;
        /** page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page */
        page?: number;
        /** number of items per page */
        per_page?: number;
      };
    };
    responses: {
      200: responses["GitTreeResponse"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoListHooks: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["HookList"];
      404: responses["notFound"];
    };
  };
  repoCreateHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateHookOption"];
      };
    };
    responses: {
      201: responses["Hook"];
      404: responses["notFound"];
    };
  };
  repoListGitHooks: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["GitHookList"];
      404: responses["notFound"];
    };
  };
  repoGetGitHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to get */
        id: string;
      };
    };
    responses: {
      200: responses["GitHook"];
      404: responses["notFound"];
    };
  };
  repoDeleteGitHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to get */
        id: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoEditGitHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to get */
        id: string;
      };
      body: {
        body?: definitions["EditGitHookOption"];
      };
    };
    responses: {
      200: responses["GitHook"];
      404: responses["notFound"];
    };
  };
  repoGetHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to get */
        id: number;
      };
    };
    responses: {
      200: responses["Hook"];
      404: responses["notFound"];
    };
  };
  repoDeleteHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoEditHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the hook */
        id: number;
      };
      body: {
        body?: definitions["EditHookOption"];
      };
    };
    responses: {
      200: responses["Hook"];
      404: responses["notFound"];
    };
  };
  repoTestHook: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the hook to test */
        id: number;
      };
      query: {
        /** The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. */
        ref?: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoGetIssueConfig: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["RepoIssueConfig"];
      404: responses["notFound"];
    };
  };
  repoValidateIssueConfig: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["RepoIssueConfigValidation"];
      404: responses["notFound"];
    };
  };
  repoGetIssueTemplates: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["IssueTemplates"];
      404: responses["notFound"];
    };
  };
  issueListIssues: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** whether issue is open or closed */
        state?: "closed" | "open" | "all";
        /** comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded */
        labels?: string;
        /** search string */
        q?: string;
        /** filter by type (issues / pulls) if set */
        type?: "issues" | "pulls";
        /** comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded */
        milestones?: string;
        /** Only show items updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show items updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** Only show items which were created by the given user */
        created_by?: string;
        /** Only show items for which the given user is assigned */
        assigned_by?: string;
        /** Only show items in which the given user was mentioned */
        mentioned_by?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["IssueList"];
      404: responses["notFound"];
    };
  };
  issueCreateIssue: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateIssueOption"];
      };
    };
    responses: {
      201: responses["Issue"];
      403: responses["forbidden"];
      404: responses["notFound"];
      412: responses["error"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  issueGetRepoComments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** if provided, only comments updated since the provided time are returned. */
        since?: string;
        /** if provided, only comments updated before the provided time are returned. */
        before?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["CommentList"];
      404: responses["notFound"];
    };
  };
  issueGetComment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
      };
    };
    responses: {
      200: responses["Comment"];
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueDeleteComment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of comment to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueEditComment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment to edit */
        id: number;
      };
      body: {
        body?: definitions["EditIssueCommentOption"];
      };
    };
    responses: {
      200: responses["Comment"];
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  issueListIssueCommentAttachments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
      };
    };
    responses: {
      200: responses["AttachmentList"];
      404: responses["error"];
    };
  };
  issueCreateIssueCommentAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
      };
      query: {
        /** name of the attachment */
        name?: string;
      };
      formData: {
        /** attachment to upload */
        attachment: unknown;
      };
    };
    responses: {
      201: responses["Attachment"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["error"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  issueGetIssueCommentAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
        /** id of the attachment to get */
        attachment_id: number;
      };
    };
    responses: {
      200: responses["Attachment"];
      404: responses["error"];
    };
  };
  issueDeleteIssueCommentAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
        /** id of the attachment to delete */
        attachment_id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  issueEditIssueCommentAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment */
        id: number;
        /** id of the attachment to edit */
        attachment_id: number;
      };
      body: {
        body?: definitions["EditAttachmentOptions"];
      };
    };
    responses: {
      201: responses["Attachment"];
      404: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  issueGetCommentReactions: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment to edit */
        id: number;
      };
    };
    responses: {
      200: responses["ReactionList"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issuePostCommentReaction: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment to edit */
        id: number;
      };
      body: {
        content?: definitions["EditReactionOption"];
      };
    };
    responses: {
      200: responses["Reaction"];
      201: responses["Reaction"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueDeleteCommentReaction: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the comment to edit */
        id: number;
      };
      body: {
        content?: definitions["EditReactionOption"];
      };
    };
    responses: {
      200: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoListPinnedIssues: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["IssueList"];
      404: responses["notFound"];
    };
  };
  issueGetIssue: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to get */
        index: number;
      };
    };
    responses: {
      200: responses["Issue"];
      404: responses["notFound"];
    };
  };
  issueDelete: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of issue to delete */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueEditIssue: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to edit */
        index: number;
      };
      body: {
        body?: definitions["EditIssueOption"];
      };
    };
    responses: {
      201: responses["Issue"];
      403: responses["forbidden"];
      404: responses["notFound"];
      412: responses["error"];
    };
  };
  issueListIssueAttachments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
    };
    responses: {
      200: responses["AttachmentList"];
      404: responses["error"];
    };
  };
  issueCreateIssueAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** name of the attachment */
        name?: string;
      };
      formData: {
        /** attachment to upload */
        attachment: unknown;
      };
    };
    responses: {
      201: responses["Attachment"];
      400: responses["error"];
      404: responses["error"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  issueGetIssueAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** id of the attachment to get */
        attachment_id: number;
      };
    };
    responses: {
      200: responses["Attachment"];
      404: responses["error"];
    };
  };
  issueDeleteIssueAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** id of the attachment to delete */
        attachment_id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  issueEditIssueAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** id of the attachment to edit */
        attachment_id: number;
      };
      body: {
        body?: definitions["EditAttachmentOptions"];
      };
    };
    responses: {
      201: responses["Attachment"];
      404: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  issueListBlocks: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["IssueList"];
      404: responses["notFound"];
    };
  };
  issueCreateIssueBlocking: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      body: {
        body?: definitions["IssueMeta"];
      };
    };
    responses: {
      201: responses["Issue"];
      /** the issue does not exist */
      404: unknown;
    };
  };
  issueRemoveIssueBlocking: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      body: {
        body?: definitions["IssueMeta"];
      };
    };
    responses: {
      200: responses["Issue"];
      404: responses["notFound"];
    };
  };
  issueGetComments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** if provided, only comments updated since the specified time are returned. */
        since?: string;
        /** if provided, only comments updated before the provided time are returned. */
        before?: string;
      };
    };
    responses: {
      200: responses["CommentList"];
      404: responses["notFound"];
    };
  };
  issueCreateComment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        body?: definitions["CreateIssueCommentOption"];
      };
    };
    responses: {
      201: responses["Comment"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  issueDeleteCommentDeprecated: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** this parameter is ignored */
        index: number;
        /** id of comment to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueEditCommentDeprecated: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** this parameter is ignored */
        index: number;
        /** id of the comment to edit */
        id: number;
      };
      body: {
        body?: definitions["EditIssueCommentOption"];
      };
    };
    responses: {
      200: responses["Comment"];
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueEditIssueDeadline: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to create or update a deadline on */
        index: number;
      };
      body: {
        body?: definitions["EditDeadlineOption"];
      };
    };
    responses: {
      201: responses["IssueDeadline"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueListIssueDependencies: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["IssueList"];
      404: responses["notFound"];
    };
  };
  issueCreateIssueDependencies: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      body: {
        body?: definitions["IssueMeta"];
      };
    };
    responses: {
      201: responses["Issue"];
      /** the issue does not exist */
      404: unknown;
      423: responses["repoArchivedError"];
    };
  };
  issueRemoveIssueDependencies: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: string;
      };
      body: {
        body?: definitions["IssueMeta"];
      };
    };
    responses: {
      200: responses["Issue"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  issueGetLabels: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
    };
    responses: {
      200: responses["LabelList"];
      404: responses["notFound"];
    };
  };
  issueReplaceLabels: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        body?: definitions["IssueLabelsOption"];
      };
    };
    responses: {
      200: responses["LabelList"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueAddLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        body?: definitions["IssueLabelsOption"];
      };
    };
    responses: {
      200: responses["LabelList"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueClearLabels: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueRemoveLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** id of the label to remove */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  pinIssue: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of issue to pin */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  unpinIssue: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of issue to unpin */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  moveIssuePin: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of issue */
        index: number;
        /** the new position */
        position: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueGetIssueReactions: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ReactionList"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issuePostIssueReaction: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        content?: definitions["EditReactionOption"];
      };
    };
    responses: {
      200: responses["Reaction"];
      201: responses["Reaction"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueDeleteIssueReaction: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        content?: definitions["EditReactionOption"];
      };
    };
    responses: {
      200: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueDeleteStopWatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to stop the stopwatch on */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      /** Not repo writer, user does not have rights to toggle stopwatch */
      403: unknown;
      404: responses["notFound"];
      /** Cannot cancel a non existent stopwatch */
      409: unknown;
    };
  };
  issueStartStopWatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to create the stopwatch on */
        index: number;
      };
    };
    responses: {
      201: responses["empty"];
      /** Not repo writer, user does not have rights to toggle stopwatch */
      403: unknown;
      404: responses["notFound"];
      /** Cannot start a stopwatch again if it already exists */
      409: unknown;
    };
  };
  issueStopStopWatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to stop the stopwatch on */
        index: number;
      };
    };
    responses: {
      201: responses["empty"];
      /** Not repo writer, user does not have rights to toggle stopwatch */
      403: unknown;
      404: responses["notFound"];
      /** Cannot stop a non existent stopwatch */
      409: unknown;
    };
  };
  issueSubscriptions: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  issueCheckSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
    };
    responses: {
      200: responses["WatchInfo"];
      404: responses["notFound"];
    };
  };
  issueAddSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** user to subscribe */
        user: string;
      };
    };
    responses: {
      /** Already subscribed */
      200: unknown;
      /** Successfully Subscribed */
      201: unknown;
      /** User can only subscribe itself if he is no admin */
      304: never;
      404: responses["notFound"];
    };
  };
  issueDeleteSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** user witch unsubscribe */
        user: string;
      };
    };
    responses: {
      /** Already unsubscribed */
      200: unknown;
      /** Successfully Unsubscribed */
      201: unknown;
      /** User can only subscribe itself if he is no admin */
      304: never;
      404: responses["notFound"];
    };
  };
  issueGetCommentsAndTimeline: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** if provided, only comments updated since the specified time are returned. */
        since?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
        /** if provided, only comments updated before the provided time are returned. */
        before?: string;
      };
    };
    responses: {
      200: responses["TimelineList"];
      404: responses["notFound"];
    };
  };
  issueTrackedTimes: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      query: {
        /** optional filter by user (available for issue managers) */
        user?: string;
        /** Only show times updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show times updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TrackedTimeList"];
      404: responses["notFound"];
    };
  };
  issueAddTime: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
      };
      body: {
        body?: definitions["AddTimeOption"];
      };
    };
    responses: {
      200: responses["TrackedTime"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueResetTime: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue to add tracked time to */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueDeleteTime: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the issue */
        index: number;
        /** id of time to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoListKeys: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** the key_id to search for */
        key_id?: number;
        /** fingerprint of the key */
        fingerprint?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["DeployKeyList"];
      404: responses["notFound"];
    };
  };
  repoCreateKey: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateKeyOption"];
      };
    };
    responses: {
      201: responses["DeployKey"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoGetKey: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the key to get */
        id: number;
      };
    };
    responses: {
      200: responses["DeployKey"];
      404: responses["notFound"];
    };
  };
  repoDeleteKey: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the key to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  issueListLabels: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["LabelList"];
      404: responses["notFound"];
    };
  };
  issueCreateLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateLabelOption"];
      };
    };
    responses: {
      201: responses["Label"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  issueGetLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the label to get */
        id: number;
      };
    };
    responses: {
      200: responses["Label"];
      404: responses["notFound"];
    };
  };
  issueDeleteLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the label to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  issueEditLabel: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the label to edit */
        id: number;
      };
      body: {
        body?: definitions["EditLabelOption"];
      };
    };
    responses: {
      200: responses["Label"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoGetLanguages: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["LanguageStatistics"];
      404: responses["notFound"];
    };
  };
  repoGetRawFileOrLFS: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** filepath of the file to get */
        filepath: string;
      };
      query: {
        /** The name of the commit/branch/tag. Default the repository’s default branch (usually master) */
        ref?: string;
      };
    };
    responses: {
      /** Returns raw file content. */
      200: unknown;
      404: responses["notFound"];
    };
  };
  issueGetMilestonesList: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** Milestone state, Recognized values are open, closed and all. Defaults to "open" */
        state?: string;
        /** filter by milestone name */
        name?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["MilestoneList"];
      404: responses["notFound"];
    };
  };
  issueCreateMilestone: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateMilestoneOption"];
      };
    };
    responses: {
      201: responses["Milestone"];
      404: responses["notFound"];
    };
  };
  issueGetMilestone: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** the milestone to get, identified by ID and if not available by name */
        id: string;
      };
    };
    responses: {
      200: responses["Milestone"];
      404: responses["notFound"];
    };
  };
  issueDeleteMilestone: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** the milestone to delete, identified by ID and if not available by name */
        id: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  issueEditMilestone: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** the milestone to edit, identified by ID and if not available by name */
        id: string;
      };
      body: {
        body?: definitions["EditMilestoneOption"];
      };
    };
    responses: {
      200: responses["Milestone"];
      404: responses["notFound"];
    };
  };
  repoMirrorSync: {
    parameters: {
      path: {
        /** owner of the repo to sync */
        owner: string;
        /** name of the repo to sync */
        repo: string;
      };
    };
    responses: {
      200: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoNewPinAllowed: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["RepoNewIssuePinsAllowed"];
      404: responses["notFound"];
    };
  };
  notifyGetRepoList: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** If true, show notifications marked as read. Default value is false */
        all?: boolean;
        /** Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned */
        "status-types"?: string[];
        /** filter notifications by subject type */
        "subject-type"?: ("issue" | "pull" | "commit" | "repository")[];
        /** Only show notifications updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show notifications updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["NotificationThreadList"];
    };
  };
  notifyReadRepoList: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** If true, mark all notifications on this repo. Default value is false */
        all?: string;
        /** Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread. */
        "status-types"?: string[];
        /** Status to mark notifications as. Defaults to read. */
        "to-status"?: string;
        /** Describes the last point that notifications were checked. Anything updated since this time will not be updated. */
        last_read_at?: string;
      };
    };
    responses: {
      205: responses["NotificationThreadList"];
    };
  };
  repoListPullRequests: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** State of pull request: open or closed (optional) */
        state?: "closed" | "open" | "all";
        /** Type of sort */
        sort?:
          | "oldest"
          | "recentupdate"
          | "leastupdate"
          | "mostcomment"
          | "leastcomment"
          | "priority";
        /** ID of the milestone */
        milestone?: number;
        /** Label IDs */
        labels?: number[];
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["PullRequestList"];
      404: responses["notFound"];
    };
  };
  repoCreatePullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreatePullRequestOption"];
      };
    };
    responses: {
      201: responses["PullRequest"];
      403: responses["forbidden"];
      404: responses["notFound"];
      409: responses["error"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  repoListPinnedPullRequests: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["PullRequestList"];
      404: responses["notFound"];
    };
  };
  repoGetPullRequestByBaseHead: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** base of the pull request to get */
        base: string;
        /** head of the pull request to get */
        head: string;
      };
    };
    responses: {
      200: responses["PullRequest"];
      404: responses["notFound"];
    };
  };
  repoGetPullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to get */
        index: number;
      };
    };
    responses: {
      200: responses["PullRequest"];
      404: responses["notFound"];
    };
  };
  repoEditPullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to edit */
        index: number;
      };
      body: {
        body?: definitions["EditPullRequestOption"];
      };
    };
    responses: {
      201: responses["PullRequest"];
      403: responses["forbidden"];
      404: responses["notFound"];
      409: responses["error"];
      412: responses["error"];
      422: responses["validationError"];
    };
  };
  repoDownloadPullDiffOrPatch: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to get */
        index: number;
        /** whether the output is diff or patch */
        diffType: "diff" | "patch";
      };
      query: {
        /** whether to include binary file changes. if true, the diff is applicable with `git apply` */
        binary?: boolean;
      };
    };
    responses: {
      200: responses["string"];
      404: responses["notFound"];
    };
  };
  repoGetPullRequestCommits: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to get */
        index: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
        /** include verification for every commit (disable for speedup, default 'true') */
        verification?: boolean;
        /** include a list of affected files for every commit (disable for speedup, default 'true') */
        files?: boolean;
      };
    };
    responses: {
      200: responses["CommitList"];
      404: responses["notFound"];
    };
  };
  repoGetPullRequestFiles: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to get */
        index: number;
      };
      query: {
        /** skip to given file */
        "skip-to"?: string;
        /** whitespace behavior */
        whitespace?: "ignore-all" | "ignore-change" | "ignore-eol" | "show-all";
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ChangedFileList"];
      404: responses["notFound"];
    };
  };
  repoPullRequestIsMerged: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
      };
    };
    responses: {
      /** pull request has been merged */
      204: never;
      /** pull request has not been merged */
      404: unknown;
    };
  };
  repoMergePullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to merge */
        index: number;
      };
      body: {
        body?: definitions["MergePullRequestOption"];
      };
    };
    responses: {
      200: responses["empty"];
      404: responses["notFound"];
      405: responses["empty"];
      409: responses["error"];
      423: responses["repoArchivedError"];
    };
  };
  repoCancelScheduledAutoMerge: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to merge */
        index: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoCreatePullReviewRequests: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
      };
      body: {
        body: definitions["PullReviewRequestOptions"];
      };
    };
    responses: {
      201: responses["PullReviewList"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoDeletePullReviewRequests: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
      };
      body: {
        body: definitions["PullReviewRequestOptions"];
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoListPullReviews: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["PullReviewList"];
      404: responses["notFound"];
    };
  };
  repoCreatePullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
      };
      body: {
        body: definitions["CreatePullReviewOptions"];
      };
    };
    responses: {
      200: responses["PullReview"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoGetPullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
    };
    responses: {
      200: responses["PullReview"];
      404: responses["notFound"];
    };
  };
  repoSubmitPullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
      body: {
        body: definitions["SubmitPullReviewOptions"];
      };
    };
    responses: {
      200: responses["PullReview"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoDeletePullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoGetPullReviewComments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
    };
    responses: {
      200: responses["PullReviewCommentList"];
      404: responses["notFound"];
    };
  };
  repoDismissPullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
      body: {
        body: definitions["DismissPullReviewOptions"];
      };
    };
    responses: {
      200: responses["PullReview"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoUnDismissPullReview: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request */
        index: number;
        /** id of the review */
        id: number;
      };
    };
    responses: {
      200: responses["PullReview"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoUpdatePullRequest: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** index of the pull request to get */
        index: number;
      };
      query: {
        /** how to update pull request */
        style?: "merge" | "rebase";
      };
    };
    responses: {
      200: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      409: responses["error"];
      422: responses["validationError"];
    };
  };
  repoListPushMirrors: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["PushMirrorList"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoAddPushMirror: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreatePushMirrorOption"];
      };
    };
    responses: {
      200: responses["PushMirror"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoPushMirrorSync: {
    parameters: {
      path: {
        /** owner of the repo to sync */
        owner: string;
        /** name of the repo to sync */
        repo: string;
      };
    };
    responses: {
      200: responses["empty"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoGetPushMirrorByRemoteName: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** remote name of push mirror */
        name: string;
      };
    };
    responses: {
      200: responses["PushMirror"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoDeletePushMirror: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** remote name of the pushMirror */
        name: string;
      };
    };
    responses: {
      204: responses["empty"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoGetRawFile: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** filepath of the file to get */
        filepath: string;
      };
      query: {
        /** The name of the commit/branch/tag. Default the repository’s default branch (usually master) */
        ref?: string;
      };
    };
    responses: {
      /** Returns raw file content. */
      200: unknown;
      404: responses["notFound"];
    };
  };
  repoListReleases: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** filter (exclude / include) drafts, if you dont have repo write access none will show */
        draft?: boolean;
        /** filter (exclude / include) pre-releases */
        "pre-release"?: boolean;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ReleaseList"];
      404: responses["notFound"];
    };
  };
  repoCreateRelease: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateReleaseOption"];
      };
    };
    responses: {
      201: responses["Release"];
      404: responses["notFound"];
      409: responses["error"];
      422: responses["validationError"];
    };
  };
  repoGetLatestRelease: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["Release"];
      404: responses["notFound"];
    };
  };
  repoGetReleaseByTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** tag name of the release to get */
        tag: string;
      };
    };
    responses: {
      200: responses["Release"];
      404: responses["notFound"];
    };
  };
  repoDeleteReleaseByTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** tag name of the release to delete */
        tag: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoGetRelease: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release to get */
        id: number;
      };
    };
    responses: {
      200: responses["Release"];
      404: responses["notFound"];
    };
  };
  repoDeleteRelease: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  repoEditRelease: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release to edit */
        id: number;
      };
      body: {
        body?: definitions["EditReleaseOption"];
      };
    };
    responses: {
      200: responses["Release"];
      404: responses["notFound"];
    };
  };
  repoListReleaseAttachments: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release */
        id: number;
      };
    };
    responses: {
      200: responses["AttachmentList"];
      404: responses["notFound"];
    };
  };
  repoCreateReleaseAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release */
        id: number;
      };
      query: {
        /** name of the attachment */
        name?: string;
      };
      formData: {
        /** attachment to upload */
        attachment?: unknown;
      };
    };
    responses: {
      201: responses["Attachment"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoGetReleaseAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release */
        id: number;
        /** id of the attachment to get */
        attachment_id: number;
      };
    };
    responses: {
      200: responses["Attachment"];
      404: responses["notFound"];
    };
  };
  repoDeleteReleaseAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release */
        id: number;
        /** id of the attachment to delete */
        attachment_id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoEditReleaseAttachment: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** id of the release */
        id: number;
        /** id of the attachment to edit */
        attachment_id: number;
      };
      body: {
        body?: definitions["EditAttachmentOptions"];
      };
    };
    responses: {
      201: responses["Attachment"];
      404: responses["notFound"];
    };
  };
  repoGetReviewers: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  repoGetRunnerRegistrationToken: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["RegistrationToken"];
    };
  };
  repoSigningKey: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      /** GPG armored public key */
      200: {
        schema: string;
      };
    };
  };
  repoListStargazers: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  repoListStatuses: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** sha of the commit */
        sha: string;
      };
      query: {
        /** type of sort */
        sort?:
          | "oldest"
          | "recentupdate"
          | "leastupdate"
          | "leastindex"
          | "highestindex";
        /** type of state */
        state?: "pending" | "success" | "error" | "failure" | "warning";
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["CommitStatusList"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoCreateStatus: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** sha of the commit */
        sha: string;
      };
      body: {
        body?: definitions["CreateStatusOption"];
      };
    };
    responses: {
      201: responses["CommitStatus"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  repoListSubscribers: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  userCurrentCheckSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["WatchInfo"];
      /** User is not watching this repo or repo do not exist */
      404: unknown;
    };
  };
  userCurrentPutSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["WatchInfo"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userCurrentDeleteSubscription: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  repoListTags: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results, default maximum page size is 50 */
        limit?: number;
      };
    };
    responses: {
      200: responses["TagList"];
      404: responses["notFound"];
    };
  };
  repoCreateTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateTagOption"];
      };
    };
    responses: {
      200: responses["Tag"];
      404: responses["notFound"];
      405: responses["empty"];
      409: responses["conflict"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of tag */
        tag: string;
      };
    };
    responses: {
      200: responses["Tag"];
      404: responses["notFound"];
    };
  };
  repoDeleteTag: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of tag to delete */
        tag: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      405: responses["empty"];
      409: responses["conflict"];
      422: responses["validationError"];
      423: responses["repoArchivedError"];
    };
  };
  repoListTeams: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      200: responses["TeamList"];
      404: responses["notFound"];
    };
  };
  repoCheckTeam: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** team name */
        team: string;
      };
    };
    responses: {
      200: responses["Team"];
      404: responses["notFound"];
      405: responses["error"];
    };
  };
  repoAddTeam: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** team name */
        team: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      405: responses["error"];
      422: responses["validationError"];
    };
  };
  repoDeleteTeam: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** team name */
        team: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      405: responses["error"];
      422: responses["validationError"];
    };
  };
  repoTrackedTimes: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** optional filter by user (available for issue managers) */
        user?: string;
        /** Only show times updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show times updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TrackedTimeList"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userTrackedTimes: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** username of user */
        user: string;
      };
    };
    responses: {
      200: responses["TrackedTimeList"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoListTopics: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TopicNames"];
      404: responses["notFound"];
    };
  };
  repoUpdateTopics: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["RepoTopicOptions"];
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["invalidTopicsError"];
    };
  };
  repoAddTopic: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the topic to add */
        topic: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["invalidTopicsError"];
    };
  };
  repoDeleteTopic: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the topic to delete */
        topic: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["invalidTopicsError"];
    };
  };
  repoTransfer: {
    parameters: {
      path: {
        /** owner of the repo to transfer */
        owner: string;
        /** name of the repo to transfer */
        repo: string;
      };
      body: {
        /** Transfer Options */
        body: definitions["TransferRepoOption"];
      };
    };
    responses: {
      202: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  acceptRepoTransfer: {
    parameters: {
      path: {
        /** owner of the repo to transfer */
        owner: string;
        /** name of the repo to transfer */
        repo: string;
      };
    };
    responses: {
      202: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  rejectRepoTransfer: {
    parameters: {
      path: {
        /** owner of the repo to transfer */
        owner: string;
        /** name of the repo to transfer */
        repo: string;
      };
    };
    responses: {
      200: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  repoCreateWikiPage: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      body: {
        body?: definitions["CreateWikiPageOptions"];
      };
    };
    responses: {
      201: responses["WikiPage"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetWikiPage: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the page */
        pageName: string;
      };
    };
    responses: {
      200: responses["WikiPage"];
      404: responses["notFound"];
    };
  };
  repoDeleteWikiPage: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the page */
        pageName: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoEditWikiPage: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the page */
        pageName: string;
      };
      body: {
        body?: definitions["CreateWikiPageOptions"];
      };
    };
    responses: {
      200: responses["WikiPage"];
      400: responses["error"];
      403: responses["forbidden"];
      404: responses["notFound"];
      423: responses["repoArchivedError"];
    };
  };
  repoGetWikiPages: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["WikiPageList"];
      404: responses["notFound"];
    };
  };
  repoGetWikiPageRevisions: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
        /** name of the page */
        pageName: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
      };
    };
    responses: {
      200: responses["WikiCommitList"];
      404: responses["notFound"];
    };
  };
  generateRepo: {
    parameters: {
      path: {
        /** name of the template repository owner */
        template_owner: string;
        /** name of the template repository */
        template_repo: string;
      };
      body: {
        body?: definitions["GenerateRepoOption"];
      };
    };
    responses: {
      201: responses["Repository"];
      403: responses["forbidden"];
      404: responses["notFound"];
      /** The repository with the same name already exists. */
      409: unknown;
      422: responses["validationError"];
    };
  };
  repoGetByID: {
    parameters: {
      path: {
        /** id of the repo to get */
        id: number;
      };
    };
    responses: {
      200: responses["Repository"];
      404: responses["notFound"];
    };
  };
  getGeneralAPISettings: {
    responses: {
      200: responses["GeneralAPISettings"];
    };
  };
  getGeneralAttachmentSettings: {
    responses: {
      200: responses["GeneralAttachmentSettings"];
    };
  };
  getGeneralRepositorySettings: {
    responses: {
      200: responses["GeneralRepoSettings"];
    };
  };
  getGeneralUISettings: {
    responses: {
      200: responses["GeneralUISettings"];
    };
  };
  getSigningKey: {
    responses: {
      /** GPG armored public key */
      200: {
        schema: string;
      };
    };
  };
  orgGetTeam: {
    parameters: {
      path: {
        /** id of the team to get */
        id: number;
      };
    };
    responses: {
      200: responses["Team"];
      404: responses["notFound"];
    };
  };
  orgDeleteTeam: {
    parameters: {
      path: {
        /** id of the team to delete */
        id: number;
      };
    };
    responses: {
      /** team deleted */
      204: never;
      404: responses["notFound"];
    };
  };
  orgEditTeam: {
    parameters: {
      path: {
        /** id of the team to edit */
        id: number;
      };
      body: {
        body?: definitions["EditTeamOption"];
      };
    };
    responses: {
      200: responses["Team"];
      404: responses["notFound"];
    };
  };
  orgListTeamActivityFeeds: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
      };
      query: {
        /** the date of the activities to be found */
        date?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ActivityFeedsList"];
      404: responses["notFound"];
    };
  };
  orgListTeamMembers: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  orgListTeamMember: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** username of the member to list */
        username: string;
      };
    };
    responses: {
      200: responses["User"];
      404: responses["notFound"];
    };
  };
  orgAddTeamMember: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** username of the user to add */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  orgRemoveTeamMember: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** username of the user to remove */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  orgListTeamRepos: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  orgListTeamRepo: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** organization that owns the repo to list */
        org: string;
        /** name of the repo to list */
        repo: string;
      };
    };
    responses: {
      200: responses["Repository"];
      404: responses["notFound"];
    };
  };
  orgAddTeamRepository: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** organization that owns the repo to add */
        org: string;
        /** name of the repo to add */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  /** This does not delete the repository, it only removes the repository from the team. */
  orgRemoveTeamRepository: {
    parameters: {
      path: {
        /** id of the team */
        id: number;
        /** organization that owns the repo to remove */
        org: string;
        /** name of the repo to remove */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  topicSearch: {
    parameters: {
      query: {
        /** keywords to search */
        q: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TopicListResponse"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userGetCurrent: {
    responses: {
      200: responses["User"];
    };
  };
  userGetRunnerRegistrationToken: {
    responses: {
      200: responses["RegistrationToken"];
    };
  };
  updateUserSecret: {
    parameters: {
      path: {
        /** name of the secret */
        secretname: string;
      };
      body: {
        body?: definitions["CreateOrUpdateSecretOption"];
      };
    };
    responses: {
      /** response when creating a secret */
      201: unknown;
      /** response when updating a secret */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteUserSecret: {
    parameters: {
      path: {
        /** name of the secret */
        secretname: string;
      };
    };
    responses: {
      /** delete one secret of the user */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  getUserVariablesList: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["VariableList"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  getUserVariable: {
    parameters: {
      path: {
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      200: responses["ActionVariable"];
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  updateUserVariable: {
    parameters: {
      path: {
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["UpdateVariableOption"];
      };
    };
    responses: {
      /** response when updating a variable */
      201: unknown;
      /** response when updating a variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  createUserVariable: {
    parameters: {
      path: {
        /** name of the variable */
        variablename: string;
      };
      body: {
        body?: definitions["CreateVariableOption"];
      };
    };
    responses: {
      /** response when creating a variable */
      201: unknown;
      /** response when creating a variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  deleteUserVariable: {
    parameters: {
      path: {
        /** name of the variable */
        variablename: string;
      };
    };
    responses: {
      /** response when deleting a variable */
      201: unknown;
      /** response when deleting a variable */
      204: never;
      400: responses["error"];
      404: responses["notFound"];
    };
  };
  userGetOauth2Application: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["OAuth2ApplicationList"];
    };
  };
  userCreateOAuth2Application: {
    parameters: {
      body: {
        body: definitions["CreateOAuth2ApplicationOptions"];
      };
    };
    responses: {
      201: responses["OAuth2Application"];
      400: responses["error"];
    };
  };
  userGetOAuth2Application: {
    parameters: {
      path: {
        /** Application ID to be found */
        id: number;
      };
    };
    responses: {
      200: responses["OAuth2Application"];
      404: responses["notFound"];
    };
  };
  userDeleteOAuth2Application: {
    parameters: {
      path: {
        /** token to be deleted */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userUpdateOAuth2Application: {
    parameters: {
      path: {
        /** application to be updated */
        id: number;
      };
      body: {
        body: definitions["CreateOAuth2ApplicationOptions"];
      };
    };
    responses: {
      200: responses["OAuth2Application"];
      404: responses["notFound"];
    };
  };
  userUpdateAvatar: {
    parameters: {
      body: {
        body?: definitions["UpdateUserAvatarOption"];
      };
    };
    responses: {
      204: responses["empty"];
    };
  };
  userDeleteAvatar: {
    responses: {
      204: responses["empty"];
    };
  };
  userListBlocks: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
    };
  };
  userCheckUserBlock: {
    parameters: {
      path: {
        /** user to check */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userBlockUser: {
    parameters: {
      path: {
        /** user to block */
        username: string;
      };
      query: {
        /** optional note for the block */
        note?: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  userUnblockUser: {
    parameters: {
      path: {
        /** user to unblock */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  userListEmails: {
    responses: {
      200: responses["EmailList"];
    };
  };
  userAddEmail: {
    parameters: {
      body: {
        body?: definitions["CreateEmailOption"];
      };
    };
    responses: {
      201: responses["EmailList"];
      422: responses["validationError"];
    };
  };
  userDeleteEmail: {
    parameters: {
      body: {
        body?: definitions["DeleteEmailOption"];
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userCurrentListFollowers: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
    };
  };
  userCurrentListFollowing: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
    };
  };
  userCurrentCheckFollowing: {
    parameters: {
      path: {
        /** username of followed user */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userCurrentPutFollow: {
    parameters: {
      path: {
        /** username of user to follow */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userCurrentDeleteFollow: {
    parameters: {
      path: {
        /** username of user to unfollow */
        username: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  getVerificationToken: {
    responses: {
      200: responses["string"];
      404: responses["notFound"];
    };
  };
  userVerifyGPGKey: {
    responses: {
      201: responses["GPGKey"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  userCurrentListGPGKeys: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["GPGKeyList"];
    };
  };
  userCurrentPostGPGKey: {
    parameters: {
      body: {
        Form?: definitions["CreateGPGKeyOption"];
      };
    };
    responses: {
      201: responses["GPGKey"];
      404: responses["notFound"];
      422: responses["validationError"];
    };
  };
  userCurrentGetGPGKey: {
    parameters: {
      path: {
        /** id of key to get */
        id: number;
      };
    };
    responses: {
      200: responses["GPGKey"];
      404: responses["notFound"];
    };
  };
  userCurrentDeleteGPGKey: {
    parameters: {
      path: {
        /** id of key to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userListHooks: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["HookList"];
    };
  };
  userCreateHook: {
    parameters: {
      body: {
        body: definitions["CreateHookOption"];
      };
    };
    responses: {
      201: responses["Hook"];
    };
  };
  userGetHook: {
    parameters: {
      path: {
        /** id of the hook to get */
        id: number;
      };
    };
    responses: {
      200: responses["Hook"];
    };
  };
  userDeleteHook: {
    parameters: {
      path: {
        /** id of the hook to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
    };
  };
  userEditHook: {
    parameters: {
      path: {
        /** id of the hook to update */
        id: number;
      };
      body: {
        body?: definitions["EditHookOption"];
      };
    };
    responses: {
      200: responses["Hook"];
    };
  };
  userCurrentListKeys: {
    parameters: {
      query: {
        /** fingerprint of the key */
        fingerprint?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["PublicKeyList"];
    };
  };
  userCurrentPostKey: {
    parameters: {
      body: {
        body?: definitions["CreateKeyOption"];
      };
    };
    responses: {
      201: responses["PublicKey"];
      422: responses["validationError"];
    };
  };
  userCurrentGetKey: {
    parameters: {
      path: {
        /** id of key to get */
        id: number;
      };
    };
    responses: {
      200: responses["PublicKey"];
      404: responses["notFound"];
    };
  };
  userCurrentDeleteKey: {
    parameters: {
      path: {
        /** id of key to delete */
        id: number;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  orgListCurrentUserOrgs: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["OrganizationList"];
      404: responses["notFound"];
    };
  };
  userCurrentListRepos: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
    };
  };
  createCurrentUserRepo: {
    parameters: {
      body: {
        body?: definitions["CreateRepoOption"];
      };
    };
    responses: {
      201: responses["Repository"];
      400: responses["error"];
      /** The repository with the same name already exists. */
      409: unknown;
      422: responses["validationError"];
    };
  };
  getUserSettings: {
    responses: {
      200: responses["UserSettings"];
    };
  };
  updateUserSettings: {
    parameters: {
      body: {
        body?: definitions["UserSettingsOptions"];
      };
    };
    responses: {
      200: responses["UserSettings"];
    };
  };
  userCurrentListStarred: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
    };
  };
  userCurrentCheckStarring: {
    parameters: {
      path: {
        /** owner of the repo */
        owner: string;
        /** name of the repo */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userCurrentPutStar: {
    parameters: {
      path: {
        /** owner of the repo to star */
        owner: string;
        /** name of the repo to star */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userCurrentDeleteStar: {
    parameters: {
      path: {
        /** owner of the repo to unstar */
        owner: string;
        /** name of the repo to unstar */
        repo: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userGetStopWatches: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["StopWatchList"];
    };
  };
  userCurrentListSubscriptions: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
    };
  };
  userListTeams: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["TeamList"];
    };
  };
  userCurrentTrackedTimes: {
    parameters: {
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
        /** Only show times updated after the given time. This is a timestamp in RFC 3339 format */
        since?: string;
        /** Only show times updated before the given time. This is a timestamp in RFC 3339 format */
        before?: string;
      };
    };
    responses: {
      200: responses["TrackedTimeList"];
    };
  };
  userSearch: {
    parameters: {
      query: {
        /** keyword */
        q?: string;
        /** ID of the user to search for */
        uid?: number;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      /** SearchResults of a successful search */
      200: {
        schema: {
          data?: definitions["User"][];
          ok?: boolean;
        };
      };
    };
  };
  userGet: {
    parameters: {
      path: {
        /** username of user to get */
        username: string;
      };
    };
    responses: {
      200: responses["User"];
      404: responses["notFound"];
    };
  };
  userListActivityFeeds: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** if true, only show actions performed by the requested user */
        "only-performed-by"?: boolean;
        /** the date of the activities to be found */
        date?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["ActivityFeedsList"];
      404: responses["notFound"];
    };
  };
  userListFollowers: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  userListFollowing: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["UserList"];
      404: responses["notFound"];
    };
  };
  userCheckFollowing: {
    parameters: {
      path: {
        /** username of following user */
        username: string;
        /** username of followed user */
        target: string;
      };
    };
    responses: {
      204: responses["empty"];
      404: responses["notFound"];
    };
  };
  userListGPGKeys: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["GPGKeyList"];
      404: responses["notFound"];
    };
  };
  userGetHeatmapData: {
    parameters: {
      path: {
        /** username of user to get */
        username: string;
      };
    };
    responses: {
      200: responses["UserHeatmapData"];
      404: responses["notFound"];
    };
  };
  userListKeys: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** fingerprint of the key */
        fingerprint?: string;
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["PublicKeyList"];
      404: responses["notFound"];
    };
  };
  orgListUserOrgs: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["OrganizationList"];
      404: responses["notFound"];
    };
  };
  orgGetUserPermissions: {
    parameters: {
      path: {
        /** username of user */
        username: string;
        /** name of the organization */
        org: string;
      };
    };
    responses: {
      200: responses["OrganizationPermissions"];
      403: responses["forbidden"];
      404: responses["notFound"];
    };
  };
  userListRepos: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  userListStarred: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  userListSubscriptions: {
    parameters: {
      path: {
        /** username of the user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["RepositoryList"];
      404: responses["notFound"];
    };
  };
  userGetTokens: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      query: {
        /** page number of results to return (1-based) */
        page?: number;
        /** page size of results */
        limit?: number;
      };
    };
    responses: {
      200: responses["AccessTokenList"];
      403: responses["forbidden"];
    };
  };
  userCreateToken: {
    parameters: {
      path: {
        /** username of user */
        username: string;
      };
      body: {
        body?: definitions["CreateAccessTokenOption"];
      };
    };
    responses: {
      201: responses["AccessToken"];
      400: responses["error"];
      403: responses["forbidden"];
    };
  };
  userDeleteAccessToken: {
    parameters: {
      path: {
        /** username of user */
        username: string;
        /** token to be deleted, identified by ID and if not available by name */
        token: string;
      };
    };
    responses: {
      204: responses["empty"];
      403: responses["forbidden"];
      404: responses["notFound"];
      422: responses["error"];
    };
  };
  getVersion: {
    responses: {
      200: responses["ServerVersion"];
    };
  };
}

export interface external {}
